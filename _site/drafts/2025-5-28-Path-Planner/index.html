<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.1 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Path Planning Interface for Differential and Holonomic VEX Robots - Meilan Muto Portfolio</title>
<meta name="description" content="Personal Portfolio">


  <meta name="author" content="武藤皐蘭">
  
  <meta property="article:author" content="武藤皐蘭">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Meilan Muto Portfolio">
<meta property="og:title" content="Path Planning Interface for Differential and Holonomic VEX Robots">
<meta property="og:url" content="http://localhost:4000/drafts/2025-5-28-Path-Planner/">


  <meta property="og:description" content="Personal Portfolio">







  <meta property="article:published_time" content="2025-05-28T00:00:00+09:00">





  

  


<link rel="canonical" href="http://localhost:4000/drafts/2025-5-28-Path-Planner/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Meilan Muto Portfolio Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--default" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Meilan Muto Portfolio
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/projects/"
                
                
              >Projects</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      <h1 id="description">Description</h1>

<p>This project details the application of <a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline">cubic Hermite spline interpolation</a> in smooth path generation for differential and holonomic <a href="https://www.vexrobotics.com/">Vex</a> robots. Path generation is simplified through the use of a <a href="https://www.desmos.com/">Desmos</a> The project also proposes a simple method to generate a velocity profile given a initial and final velocity, initial and final acceleration, and distance. This is a project undertaken during my senior year of high school, and thus contains many potential improvements, some of which I will attempt to highlight in this article</p>

<h1 id="links">Links</h1>

<p><a href="https://github.com/Meilan39/Vex-Library-Public">Github Repository</a><br />
<a href="https://drive.google.com/file/d/1s2wVjT6lOR31UDFTtDkMZKHKzBM_V8rS/view">Presentation</a></p>

<p>The normal Path Planner version, where a starting and end point and velocity are can be visualized.</p>

<p><a href="https://www.desmos.com/calculator/zqpztqvvoi">Path Planner</a></p>

<p>The Path Planner Plus version, where a starting, mid, and end point and velocity can be visualized. Path Planner Plus is ideal for long or complex paths that require an extra point for optimized object avoidance.</p>

<p><a href="https://www.desmos.com/calculator/dg7kybaxyb">Path Planner Plus</a></p>

<h1 id="tools">Tools</h1>

<ul>
  <li>C++</li>
  <li>Desmos</li>
</ul>

<h1 id="motivation">Motivation</h1>

<p>The autonomous control persiod is a period within the Vex Robotics Competition, where robots run a pre-programmed autonomous routine and score points. Most teams resort to running a serise of discreate linear paths, using encoder distance or time-based approaches. A down-side to these approaches is that, when an obstacle lies between the current and desiered positions, multiple paths must be run consequtively, introducing inefficiencies and potential for large errors. The motivatin of this project was to create an interface to easily generate a continuous and flexible path between two points.</p>

<h1 id="background">Background</h1>

<h3 id="cubic-hermite-interpolation">Cubic Hermite Interpolation</h3>

<p>The overarching idea is to use an initial and end point and “velocity” pair to generate a flexible path. The initial and end point dictate the start and end point of the path, and the “velocity” dictates the orientation and it’s effect on the path. “velocity” is placed in quotations, because it does not represent the robot’s velocity at the start and end point, and rather the weight of the end-point orientations on the curvature of the path. This is an interpolation problem, and specifically, this implementation uses Hermite spline interpolation. It can be said that a Hermite spline is mathematically identical to a Bezier curve, another well-known curve interpolation algorithm. A Hermite spline is a better fit for robot path-planning because orientation at the start and end points of the path can be explicitly defined, whereas for Bezier curves, mid-points that are arbiturary in the physical context are used to define curvature.</p>

<p>As stated above, the Hermite Spline is generated using four pieces of information. They will hitherto be reffered to as follows:</p>

<p>$P_0$ ::= The x-y coordinate of the start point<br />
$P_1$ ::= The x-y coordinate of the end point<br />
$P_2$ ::= The “velocity” of the start point<br />
$P_3$ ::= The “velocity” of the end point</p>

<p>We then consider a general cubic polynomial and its derivative in terms of a parameter $t \in \mathbf{R}$ and 2-dimensional vector coeffients $a, b, c, d \in \mathbf{R^2}$.</p>

\[\begin{align*} 
P(t) &amp;= at^3+bt^2+ct+d \\
P'(t) &amp;= 3at^2+2bt+c
\end{align*}\]

<p>Natrually, parametric function $P(t)$ produces a 2-dimensional vector, or x-y coordinate, and we will define it such that $P(0)$ gives the start point of the path, and $P(1)$ gives the end point of the path. In particular, plugging 0 and 1 into $P(t)$ and $P’(t)$ gives the following.</p>

\[\begin{align*}
P(0) = P_0 &amp;= d\\
P(1) = P_1 &amp;= a + b + c + d\\
P'(0) = P_2 &amp;= c\\
P'(1) = P_3 &amp;= 3a + 2b + c
\end{align*}\]

<p>Rewritting in matrix form gives:</p>

\[\begin{bmatrix} P_0 \\ P_1 \\ P_2 \\ P_3 \end{bmatrix}
=
\begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
3 &amp; 2 &amp; 1 &amp; 0
\end{bmatrix}
\begin{bmatrix} a \\ b \\ c \\ d \end{bmatrix}\]

\[\begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
3 &amp; 2 &amp; 1 &amp; 0
\end{bmatrix} ^ {-1}
\begin{bmatrix} P_0 \\ P_1 \\ P_2 \\ P_3 \end{bmatrix}
=
\begin{bmatrix} a \\ b \\ c \\ d \end{bmatrix}\]

<p>Performing Gaussian elimination on the inverse matrix gives,</p>

\[\begin{bmatrix} a \\ b \\ c \\ d \end{bmatrix}
=
\begin{bmatrix}
2 &amp; -2 &amp; 1 &amp; 1 \\
-3 &amp; 3 &amp; -2 &amp; -1 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0 &amp; 0
\end{bmatrix}
\begin{bmatrix} P_0 \\ P_1 \\ P_2 \\ P_3 \end{bmatrix}\]

<p>To recap, the relationship above gives the coefficients of our cubic interpolation, expressed in terms of the four pieces of input information. Lastly, the parametric equation given the coeffecients is as follows.</p>

\[\begin{align*}
P(t) &amp;=
\begin{bmatrix} t^3 &amp; t^2 &amp; t &amp; 1 \end{bmatrix}
\begin{bmatrix}
2 &amp; -2 &amp; 1 &amp; 1 \\
-3 &amp; 3 &amp; -2 &amp; -1 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0 &amp; 0
\end{bmatrix}
\begin{bmatrix} P_0 \\ P_1 \\ P_2 \\ P_3 \end{bmatrix} \\
&amp;= 
\begin{bmatrix} 
2t^3-3t^2+1 &amp; -2t^3+3t^2 &amp; t^3-2t^2+t &amp; t^3-t^2 
\end{bmatrix}
\begin{bmatrix} P_0 \\ P_1 \\ P_2 \\ P_3 \end{bmatrix} \\
\end{align*}\]

<p>Therefore,</p>

\[P(t) = P_0 h_1 + P_1 h_2 + P_2 h_3 + P_3 h_4\]

<p>where,</p>

<p>$h_{1}(t) = 2t^3-3t^2+1$<br />
$h_{2}(t) = -2t^3 + 3t^2$<br />
$h_{3}(t) = t^3-2t^2+t$<br />
$h_{4}(t) = t^3-t^2$</p>

<p>$h_{1}(t)$ through $h_{4}(t)$ is refered to as the 4 Hermite baisis functions.</p>

<h3 id="velocity-profile">Velocity Profile</h3>

<p>In practice, the interpolatin function is sampled discretely during the robot initialization time given before each match. During sampling, it is also possible to calculate a discrete approximation of the first and second order derivatives of the path. This information can be important because fast robots may want to scale their velocity as to not overrun or tip when passing through sharp corners.</p>

<p>The objective was to define a function that can convert intuitive parameters into a flexible velocity-profile. Specifically, the function will be defined by the following 6 parameteres:</p>

<p>$d$ ::= The distance of the profile<br />
$m$ ::= The maximum velocity of the profile<br />
$k_1$ ::= acceleration constant<br />
$k_2$ ::= deceleration constant<br />
$s_1$ ::= initial velocity<br />
$s_2$ ::= final velocity</p>

<p>These 6 parameters should be sufficient to define any given velocity profile, with a relatively large degree of freedom.</p>

<p>We begin with a general form of the sigmoid function, where $a_i, b_i$ are constants.</p>

\[f(x) = \frac{1}{1 - a_ie^{-b_ix}} \left( a_i &gt; 0, b_i &gt; 0 \right)\]

<p>The “steepness” of the curve is defined by the exponential coefficient $b_i$. Thus,</p>

\[b_i = k_1\]

<p>Next, given that $f(0)$ should equal the initial velocity parameter $s_1$, $a_i$ is derived as follows.</p>

\[s_1 = f(0) = \frac{1}{1 + a_i}
\implies a_i = \frac{1}{s_1} - 1\]

<p>Similarly, the deceleration end of the profile can be defined by a generalization of the inverted sigmoid, where $a_f, b_f$ are constants.</p>

\[g(x) = \frac{1}{1 - a_fe^{b_fx}} \left( a_f &gt; 0, b_f &gt; 0 \right)\]

<p>Because the $g(0)$ of this graph should allign with $x=d$, the graph is shifted to the right by $d$ as follows:</p>

\[g(x) = \frac{1}{1 - a_fe^{b_f(x-d)}} \left( a_f &gt; 0, b_f &gt; 0 \right)\]

<p>Finally, multipling the two graphs and scaling it by the maximum velocity $m$ results in the profile’s final form.</p>

<p><img src="./2025-5-28-Path-Planner-assets/xdrive.svg" alt="Velocity Profile" title="A slide from the presentation linked above" /></p>

\[mf(x)g(x) = 
\frac{m}{
  \{ 1 + ( \frac{m}{s_1} - 1 ) e^{-k_1x} \} 
  \{ 1 + ( \frac{m}{s_2} - 1 ) e^{k_2(x - d)} \} 
}\]

<h3 id="intricacies-of-holonomic-control">Intricacies of Holonomic Control</h3>

<p>Holonomic drives are robotic drive bases that are able to theoretically translate in all directions and rotate similtaneously. There are many types of holonomic drive bases, but Vex robotics is dominated by the “X-drive” (pictured below) due to its simplicity. Despite being a holonomic drive base however, the true mobility of these drives are not fully exploited at the High school level, as the control is significantly more advanced than its differential counterpart.</p>

<p>For example, given a controller with left joystick input $(lx, ly)$ and right joystick input $(r_x, r_y)$, we assign the following relationship.</p>

\[\mathbf{v} = 
\begin{bmatrix} l_x \\ l_y \end{bmatrix}
\ \ \ \ 
\omega = r_x\]

<p>where $\mathbf{v}$ represents the velocity of the robot <strong>relative to the field</strong>, and $\omega$ represents angular velocity. “relative to the field” means that, regardless of the orientation of the robot, moving the left joystick in a certain direction always moves the robot in the same direction relative to the field.</p>

<p>This method of control, typically referred to as <strong>field-centric</strong> drive control, can be achived by measuring the robot’s heading using a gyroscope, which will be refered to as $\theta$ here. Given a robot’s heading $\theta$, we can use a rotation matricy to rotate the input vector $\mathbf{v}$, $-\theta$ degrees about the origin, to convert the field-centric input into a robot-centric one. The relationship is given by,</p>

\[\mathbf{v_{robot}} =
\begin{bmatrix}
  \cos(-\theta) &amp; - \sin(-\theta) \\
  \sin(-\theta) &amp; \cos(-\theta)
\end{bmatrix}
\begin{bmatrix} l_x \\ r_x \end{bmatrix}\]

<p>Imagine that the robot has a heading of 90 degrees clockwise. Without processing, pushing the left joystick directly forward would move the robot directly to the right relative to the field. To counter-act this, the controller input is rotated -90 degrees, or 90 degrees counter-clockwise. This means that moving the left joystick directly forward tells the robot to move directly to the left, which would be correct from the robot’s persepective. This process can be restated as, <strong>converting the input expressed in the world-baisis into the robot-baisis.</strong></p>

<p><img src="./2025-5-28-Path-Planner-assets/xdrive.svg" alt="X-drive" title="A slide from the presentation linked above" /></p>

<p>Redefining $\mathbf{v}$ to $\mathbf{v_{robot}}$, we will now consider how the individual wheel motors must be moved in order to produce movement in the intended direction. The X-drive is an omni-directional drive, meaning that it can translate in any direction. We will achieve this by taking the inner-product of our velocity vector $\mathbf{v}$ and 4 unit vectors that represent the forward direction of each wheel. Specifically, front left, front right, rear left, and rear right motors given as follows.</p>

\[\mathbf{v_{fl}} = \begin{bmatrix} \cos(45) \\ \sin(45) \end{bmatrix} \ \
\mathbf{v_{fr}} = \begin{bmatrix} \cos(135) \\ \sin(135) \end{bmatrix} \ \
\mathbf{v_{rl}} = \begin{bmatrix} \cos(135) \\ \sin(135) \end{bmatrix} \ \
\mathbf{v_{rr}} = \begin{bmatrix} \cos(45) \\ \sin(45) \end{bmatrix} \ \\]

<p>Taking the inner-product of vectors can give a measure of how closely they allign in space. This information can be used to determine how much each wheel should be rotated relative to each other, to move in the desiered direction. Lastly, considering the direction of the angular velocity input $\omega$ from ealier, the velocity of each wheel is given as follows:</p>

\[\begin{align*}
v_{fl} &amp;= l_x * \cos(45)\ \ + l_y * \sin(45)\ \ + \omega \\  
v_{fr} &amp;= l_x * \cos(135) + l_y * \sin(135) - \omega \\    
v_{rl} &amp;= l_x * \cos(135) + l_y * \sin(135) + \omega \\    
v_{rr} &amp;= l_x * \cos(45)\ \  + l_y * \sin(45)\ \  - \omega
\end{align*}\]

<p>These values are then normalized by dividing each value by the largest value, ensuring that the motor output is never greater then 1, and the relative relationship of the motors are not lost. Specifically, this operation is critical in preserving the relationship derived from the inner-products.</p>

<p>In this implementation, odometry encoders are used alongside the gyroscope, to perform real-time pose estimation. Discrete integration of the encoder’s velocity is used to find the positional displacement of the robot every iteration. As these displacemment vectors are given in the robot’s baisis, they are rotated against the gyroscope heading to derive the robot’s estimated pose relative to the field. Similarly, distance traveled can be measured by discretely integrating the norm of the displacement vectors, and this feature is used to run the trajectories.</p>

<h3 id="desmos-ui">Desmos UI</h3>

<p><a href="https://www.desmos.com/calculator/zqpztqvvoi">Path Planner</a>
<a href="https://www.desmos.com/calculator/dg7kybaxyb">Path Planner Plus</a></p>

<p>The two desmos Graphs linked here serve as a UI for the trajectory generation. The dots that represent the robot’s initial and final coordinate and “velocity” can be dragged along the screen. In line with the behaivior of Hermite splines, extending the initial and final “velocities” make the increases the coresponding angle’s “control” over the path.</p>

<p>The Path Planner Plus graph serves as the UI for the extended trajectory planning scheme, which is simply a piecewise interpolation of two Hermite splines. One extra coordinate and “velocity” are added to the path, allowing greater and more direct control over the behavior of the path around the middle point.</p>

<h1 id="implementation">Implementation</h1>

<h2 id="path-generation">Path Generation</h2>

<p>The following code is a direct and naive implenmatation of the theory presented above.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">/// @brief エルミート補間式にある処理位置（x）を問い、そ地点の姿勢を返す</span>
  <span class="c1">/// @param path エルミート補間式の定義</span>
  <span class="c1">/// @param previous 前回の処理位置の姿勢</span>
  <span class="c1">/// @param x 処理位置（0から１）</span>
  <span class="c1">/// @return 処理位置（x）のロボット姿勢</span>
  <span class="n">Pose</span> <span class="nf">CubicHermiteInterpolation</span><span class="p">(</span><span class="n">Path</span> <span class="n">path</span><span class="p">,</span> <span class="n">Pose</span> <span class="n">previous</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// エルミート補間多項式の表現</span>
    <span class="kt">float</span> <span class="n">h1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//　１から始まり０に向かって低下する</span>
    <span class="kt">float</span> <span class="n">h2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>    <span class="c1">//　０から始まり１に向かって上昇する</span>
    <span class="kt">float</span> <span class="n">h3</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span>   <span class="c1">//　序盤に上に膨らみ終盤に低下する</span>
    <span class="kt">float</span> <span class="n">h4</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>         <span class="c1">//　終盤に下に膨らみ序盤に低下する</span>
    <span class="c1">// エルミート補間定義に従い処理位置（x）の姿勢を導く</span>
    <span class="n">Pose</span> <span class="n">current</span><span class="p">;</span> <span class="c1">//　姿勢オブジェクトを作成</span>
    <span class="n">current</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">h2</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">t0</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">h3</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">t1</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">h4</span><span class="p">;</span>  <span class="c1">//　x　値を導く</span>
    <span class="n">current</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">h2</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">t0</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">h3</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">t1</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">h4</span><span class="p">;</span>  <span class="c1">//　y　値を導く</span>
    <span class="c1">//　今回の位置から前回の位置を引くことでその差を表すベクトルを生成</span>
    <span class="c1">//　生成されたベクトルの角度を導き経路の角度を近似することができる</span>
    <span class="n">current</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">Vector</span> <span class="p">{</span><span class="n">current</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">previous</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">current</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">previous</span><span class="p">.</span><span class="n">y</span><span class="p">}.</span><span class="n">getAngle</span><span class="p">();</span> 
    <span class="k">return</span> <span class="n">current</span><span class="p">;</span> <span class="c1">//　姿勢を返す</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Because the only thing that changes between iterations of path generation is the parameter $t$, it is faster to group the matrix with the vector of input information as shown below, so as to require only one calculation of the polynomial’s coefficients.</p>

\[P(t) =
\begin{bmatrix} t^3 &amp; t^2 &amp; t &amp; 1 \end{bmatrix}
\begin{bmatrix}
2P_0 &amp; -2P_1 &amp; 1P_2 &amp; 1P_3 \\
-3P_0 &amp; 3P_1 &amp; -2P_2 &amp; -1P_3 \\
0 &amp; 0 &amp; 1P_1 &amp; 0 \\
1P_0 &amp; 0 &amp; 0 &amp; 0
\end{bmatrix}\]

<p>For holonomic drives, it is possible to define an orientation path distinct from the “velocity” orientation. Setting the start point of the path to 0, and the end point to 1, a vector of so-called “HolonomicPose” can be passed to define the orientation of the robot at different points of the path. For example, a pair such as {0.5, 180} would indicate that the robot should be facing 180 degrees exactly halfway through the path. These distance and angle pairs are then lineraly interpolated produce a smooth transition between each setpoint angle when the path is discreatized. The code for this given below.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">/// @param dist 特定する処理位置 (0 から 1)</span>
  <span class="c1">/// @param angle　ロボットの角度</span>
  <span class="k">struct</span> <span class="nc">HolonomicPose</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">dist</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">angle</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">/// @brief ホロノミック姿勢の std::vector をある処理位置　x で補間。</span>
  <span class="c1">/// 目的姿勢を提示された経路位置に厳密に達成する為に滑らか且つ徐々に近づいていく必要がある。</span>
  <span class="c1">/// この関数は提示された処理位置を用いて全ての処理位置のあるべき姿勢を導く役割を果たす。</span>
  <span class="c1">/// @param orientation ホロノミック姿勢の　std::vector （処理位置０と１の姿勢は必ず定義されている）</span>
  <span class="c1">/// @param x 処理位置</span>
  <span class="c1">/// @return 補間値</span>
  <span class="kt">float</span> <span class="n">InterpolateHolonomicPose</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">HolonomicPose</span><span class="o">&gt;</span> <span class="n">orientation</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">orientation</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">//　ホロノミック姿勢が示されているか</span>
      <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//　イテレータ初期化</span>
      <span class="c1">//　std::vector から現在の処理位置（x）が入る区間を探る</span>
      <span class="c1">//　区間の先頭と後尾の角度と処理位置の差を取ることで直線補間を行うことができる</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">s</span><span class="o">++</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">orientation</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//　std::vector を探索</span>
      <span class="kt">float</span> <span class="n">angleError</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">angle</span><span class="p">,</span> <span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">angle</span><span class="p">);</span>        <span class="c1">//　区間の最短角度差を求める</span>
      <span class="kt">float</span> <span class="n">distError</span> <span class="o">=</span> <span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">dist</span> <span class="o">-</span> <span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">dist</span><span class="p">;</span>                <span class="c1">//　区間の処理位置の差を求める</span>
      <span class="n">x</span> <span class="o">-=</span> <span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">dist</span><span class="p">;</span>                                                      <span class="c1">//  </span>
      <span class="k">return</span> <span class="n">bound</span><span class="p">(</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">distError</span><span class="p">)</span> <span class="o">*</span> <span class="n">angleError</span> <span class="o">+</span> <span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">angle</span> <span class="p">);</span>           <span class="c1">//  直線補間を行う</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//　ホロノミック姿勢が示されてない場合（ー１）を返す</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Code for the actual discreatization of the path is given below. The “clarity” of the path is set to 100 by default, meaning 100 points are sampled through the path, velocity profile, and orientation interpolation, and stored as a vector of “Waypoint” objects.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">struct</span> <span class="nc">Waypoint</span> <span class="p">{</span>
      <span class="n">PathType</span> <span class="n">type</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">dist</span><span class="p">;</span>
      <span class="n">Pose</span> <span class="n">heading</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="c1">/// @brief 軌道を生成する関数</span>
    <span class="c1">/// @param path エルミート補間式の定義</span>
    <span class="c1">/// @param orientation ホロノミック姿勢の　std::vector </span>
    <span class="c1">/// @param clarity 明瞭度を示す（一つの経路は100と定められている）</span>
    <span class="c1">/// @param profile 速度プロフィール</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Waypoint</span><span class="o">&gt;</span> <span class="n">generate</span><span class="p">(</span><span class="n">Path</span> <span class="n">path</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">HolonomicPose</span><span class="o">&gt;</span> <span class="n">orientation</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clarity</span><span class="p">,</span> <span class="n">StaticProfile</span> <span class="n">profile</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">segment</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">clarity</span><span class="p">;</span> <span class="c1">//　処理位置の一つ一つの区間の長さを導く</span>
        <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//　経路の長さを初期化</span>
        <span class="c1">// 現在姿勢と前回姿勢を宣言</span>
        <span class="n">Pose</span> <span class="n">previous</span> <span class="p">{</span><span class="n">path</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">t0</span><span class="p">.</span><span class="n">getAngle</span><span class="p">()};</span> <span class="c1">//　点Aの姿勢に設定　</span>
        <span class="n">Pose</span> <span class="n">current</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span> <span class="c1">//　初期化</span>
        <span class="c1">//　軌道となる経由地の配列を作成</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Waypoint</span><span class="o">&gt;</span> <span class="n">waypoints</span><span class="p">;</span>
        <span class="c1">//　明瞭度の分繰り返される（イテレータは1から始める）</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">clarity</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 現在処理位置を求める</span>
            <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">segment</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
            <span class="c1">// 処理位置を元に現在の姿勢を求める</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">CubicHermiteInterpolation</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
            <span class="c1">// 現在と前回の姿勢の差を（previous）に導入</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span><span class="p">.</span><span class="n">getError</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
            <span class="c1">// 現在角度と前回角度の差を比例拡大して逆数を取ります（この値は経路の曲率が高いほど小さくなる）</span>
            <span class="c1">// 速度プロフィールの現在処理値値を計算（区分的補間の場合、二番目の補間の際　index　が50となっている）</span>
            <span class="c1">// 上記の値はどちらとも0から1の範囲で、掛け合わせることで現在処理位置での速度を導ける。</span>
            <span class="kt">float</span> <span class="n">speed</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">autonomous_rotation_scaler</span> <span class="o">*</span> <span class="n">fabs</span><span class="p">(</span><span class="n">previous</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">profile</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">index</span><span class="p">));</span>
            <span class="c1">// 経由地に代入していく</span>
            <span class="n">Waypoint</span> <span class="n">waypoint</span><span class="p">;</span>
            <span class="n">waypoint</span><span class="p">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">length</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">+</span> <span class="n">previous</span><span class="p">.</span><span class="n">getVector</span><span class="p">().</span><span class="n">getMagnitude</span><span class="p">();</span> <span class="c1">//　各経由地間の距離の合計</span>
            <span class="c1">// ロボットを最終的に動かす関数がコントローラの入力を予想している為、アナログスティックの出力の近似</span>
            <span class="c1">// アナログスティックの出力の模倣は、進行方向と同じ角度の単位ベクトルで、その方向に全速力で進むことを意味する</span>
            <span class="c1">// 速度にかけることで適切な速度規制を可能とする</span>
            <span class="n">waypoint</span><span class="p">.</span><span class="n">heading</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cosf</span><span class="p">(</span><span class="n">previous</span><span class="p">.</span><span class="n">getVector</span><span class="p">().</span><span class="n">getAngle</span><span class="p">()</span> <span class="o">/</span> <span class="n">RadToDeg</span><span class="p">)</span> <span class="o">*</span> <span class="n">speed</span><span class="p">;</span> 
            <span class="n">waypoint</span><span class="p">.</span><span class="n">heading</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">sinf</span><span class="p">(</span><span class="n">previous</span><span class="p">.</span><span class="n">getVector</span><span class="p">().</span><span class="n">getAngle</span><span class="p">()</span> <span class="o">/</span> <span class="n">RadToDeg</span><span class="p">)</span> <span class="o">*</span> <span class="n">speed</span><span class="p">;</span>
            <span class="c1">// この処理位置で以前定義した「ホロノミック姿勢補間関数」を呼び出しあるべき角度を保存                </span>
            <span class="n">waypoint</span><span class="p">.</span><span class="n">heading</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">InterpolateHolonomicPose</span><span class="p">(</span><span class="n">orientation</span><span class="p">,</span> <span class="n">aIndex</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
            <span class="n">waypoints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">waypoint</span><span class="p">);</span><span class="c1">// 経由地を軌道に加える</span>
            <span class="c1">// 次のループに備える</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">+</span> <span class="n">previous</span><span class="p">.</span><span class="n">getVector</span><span class="p">().</span><span class="n">getMagnitude</span><span class="p">();</span> <span class="c1">// 今回の経由地間を合計距離にたす</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span> <span class="c1">// 今回の姿勢を前回の姿勢に代入</span>
        <span class="p">}</span>
        <span class="c1">// 初期姿勢と最終姿勢を定義。ホロノミック姿勢が示されていたら従って代入</span>
        <span class="k">this</span> <span class="o">-&gt;</span> <span class="n">initialPose</span> <span class="o">=</span> <span class="n">Pose</span> <span class="p">{</span><span class="n">path</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">orientation</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">orientation</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">angle</span><span class="p">};</span>
        <span class="k">this</span> <span class="o">-&gt;</span>   <span class="n">finalPose</span> <span class="o">=</span> <span class="n">Pose</span> <span class="p">{</span><span class="n">path</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">orientation</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">orientation</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">angle</span> <span class="p">};</span>
        <span class="k">this</span> <span class="o">-&gt;</span>      <span class="n">length</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>    <span class="c1">// 経路の最終的長さは経由地間の距離の合計である</span>
        <span class="k">this</span> <span class="o">-&gt;</span>      <span class="n">aIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1">// 区分的補間を行う場合ホロノミック姿勢をつける為</span>
        <span class="k">this</span> <span class="o">-&gt;</span>       <span class="n">index</span> <span class="o">=</span> <span class="n">clarity</span><span class="p">;</span> <span class="c1">// 区分的補間を行う場合速度プロフィールを継げる為</span>
        <span class="k">return</span> <span class="n">waypoints</span><span class="p">;</span>              <span class="c1">// 軌道を呼び出し主に返す</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>The field-centric Holonomic drive code as described above, is also given</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">arcadeDrive</span><span class="p">(</span> <span class="n">Vector</span> <span class="n">translation</span><span class="p">,</span> <span class="kt">float</span> <span class="n">w</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 運転士視点操作の場合得られた横断ベクトルをロボットの角度の分、逆回転</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fieldCentric</span><span class="p">)</span> <span class="n">translation</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span> <span class="o">-</span><span class="n">pose</span><span class="p">.</span><span class="n">w</span> <span class="p">);</span>
      <span class="kt">float</span> <span class="n">fr</span> <span class="o">=</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">FR_component</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">FR_component</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">w</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">fl</span> <span class="o">=</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">FL_component</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">FL_component</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">rl</span> <span class="o">=</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">RL_component</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">RL_component</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">rr</span> <span class="o">=</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">RR_component</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">RR_component</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">w</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="n">fmax</span><span class="p">(</span> <span class="n">fmax</span><span class="p">(</span> <span class="n">fabs</span><span class="p">(</span><span class="n">fr</span><span class="p">),</span> <span class="n">fabs</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span> <span class="p">),</span> <span class="n">fmax</span><span class="p">(</span> <span class="n">fabs</span><span class="p">(</span><span class="n">rl</span><span class="p">),</span> <span class="n">fabs</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 正規化</span>
          <span class="n">fr</span> <span class="o">/=</span> <span class="n">max</span><span class="p">;</span>
          <span class="n">fl</span> <span class="o">/=</span> <span class="n">max</span><span class="p">;</span>
          <span class="n">rl</span> <span class="o">/=</span> <span class="n">max</span><span class="p">;</span>
          <span class="n">rr</span> <span class="o">/=</span> <span class="n">max</span><span class="p">;</span> 
      <span class="p">}</span>
      <span class="n">fr</span> <span class="o">*=</span> <span class="n">WHEEL_MAX_RPM</span><span class="p">;</span>  <span class="c1">// 適当な速度を導く</span>
      <span class="n">fl</span> <span class="o">*=</span> <span class="n">WHEEL_MAX_RPM</span><span class="p">;</span>  <span class="c1">// 適当な速度を導く</span>
      <span class="n">rl</span> <span class="o">*=</span> <span class="n">WHEEL_MAX_RPM</span><span class="p">;</span>  <span class="c1">// 適当な速度を導く</span>
      <span class="n">rr</span> <span class="o">*=</span> <span class="n">WHEEL_MAX_RPM</span><span class="p">;</span>  <span class="c1">// 適当な速度を導く</span>
      <span class="n">FR</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">fr</span><span class="p">,</span> <span class="n">vex</span><span class="o">::</span><span class="n">velocityUnits</span><span class="o">::</span><span class="n">rpm</span><span class="p">);</span>  <span class="c1">// モータに速度命令</span>
      <span class="n">FL</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">vex</span><span class="o">::</span><span class="n">velocityUnits</span><span class="o">::</span><span class="n">rpm</span><span class="p">);</span>  <span class="c1">// モータに速度命令</span>
      <span class="n">RL</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">rl</span><span class="p">,</span> <span class="n">vex</span><span class="o">::</span><span class="n">velocityUnits</span><span class="o">::</span><span class="n">rpm</span><span class="p">);</span>  <span class="c1">// モータに速度命令</span>
      <span class="n">RR</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">rr</span><span class="p">,</span> <span class="n">vex</span><span class="o">::</span><span class="n">velocityUnits</span><span class="o">::</span><span class="n">rpm</span><span class="p">);</span>  <span class="c1">// モータに速度命令</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And finally, the path-following method is defined as such. As can be observed, pose estimation is used to update a “distanceTraveled” variable, which is then used to query the trajectory for a new waypoint. The returned waypoint has all the data necessary to simulate a controller input.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">/// @brief 経路を実行</span>
    <span class="c1">/// @param trajectory 走る経路</span>
    <span class="c1">/// @return 実行の捗り (0から1)</span>
    <span class="kt">float</span> <span class="nf">follow</span><span class="p">(</span><span class="n">HolonomicTrajectory</span> <span class="n">trajectory</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">localize</span><span class="p">();</span> <span class="c1">// 自己位置推定手法を更新</span>
        <span class="kt">float</span> <span class="n">progress</span> <span class="o">=</span> <span class="n">fitToRange</span><span class="p">(</span> <span class="n">distanceTraveled</span> <span class="o">/</span> <span class="n">trajectory</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span> <span class="c1">// 実行捗りを求める</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">progress</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// 実行が終了わってない限り</span>
            <span class="n">Waypoint</span> <span class="n">waypoint</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">distanceTraveled</span><span class="p">);</span> <span class="c1">// 走った距離を用い経路から次の経由地を特定</span>
            <span class="c1">//　ホロノミック姿勢の場合、PID制御を用いて目的角度を到達するために適切な出力を導く。</span>
            <span class="c1">//　概念的には、現在角度と目的角度の最短差を導き、その差が０に近づけるよに出力量を決める</span>
            <span class="kt">float</span> <span class="n">w</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">.</span><span class="n">orientation</span> <span class="o">?</span> <span class="n">omegaPID</span><span class="p">.</span><span class="n">get</span><span class="p">(</span> <span class="n">wrap</span><span class="p">(</span><span class="n">pose</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">waypoint</span><span class="p">.</span><span class="n">heading</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">arcadeDrive</span><span class="p">(</span> <span class="n">Vector</span> <span class="p">{</span><span class="n">waypoint</span><span class="p">.</span><span class="n">heading</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">waypoint</span><span class="p">.</span><span class="n">heading</span><span class="p">.</span><span class="n">y</span><span class="p">},</span> <span class="n">w</span> <span class="p">);</span> <span class="c1">// コントローラ操作の関数に入力</span>
            <span class="k">return</span> <span class="n">progress</span><span class="p">;</span> <span class="c1">//　実行捗りを毎回返す</span>
        <span class="p">}</span>      
        <span class="n">stop</span><span class="p">();</span>   <span class="c1">// モータを全て停止</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 経路が無事実行されたことを再び示す</span>
    <span class="p">}</span>
</code></pre></div></div>

      
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']], // Tells MathJax to look for $...$ and \(...\)
    displayMath: [['$$','$$'], ['\\[','\\]']], // Standard display math
    processEscapes: true, // Allows for escaping special characters
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] // Important to avoid conflicts
  },
  TeX: {
    equationNumbers: { autoNumber: "AMS" } // Optional: For AMS style equation numbering
  }
});
</script>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<link rel="stylesheet" href="/assets/css/custom.css">
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/Meilan39" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://jp.linkedin.com/in/meilan-muto-3b8a01355" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">Meilan Muto Portfolio</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>









  </body>
</html>
