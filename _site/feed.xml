<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-06-04T16:13:05+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Meilan Muto Portfolio</title><subtitle>Personal Portfolio</subtitle><author><name>武藤皐蘭</name></author><entry><title type="html">文化遺産の保存と共有のための３次元復元（英語版）- 共同研究</title><link href="http://localhost:4000/projects/3D-Reconstruction/" rel="alternate" type="text/html" title="文化遺産の保存と共有のための３次元復元（英語版）- 共同研究" /><published>2025-05-28T00:00:00+09:00</published><updated>2025-05-28T00:00:00+09:00</updated><id>http://localhost:4000/projects/3D-Reconstruction</id><content type="html" xml:base="http://localhost:4000/projects/3D-Reconstruction/"><![CDATA[<p>Some would say that we are currently living through the information age, a universal turning point for civilization which has the potential to rival the agricultural and industrial revolution in terms of societal impact. One important aspect of the information age is that it has enabled the sharing of information with far less work and with far more accessibility than in the past. The invention of the internet and its advancement as a global exchange for information has undoubtedly raised the bar for the collective intelligence of mankind. Increasing the amount of information that can be stored and transferred has been a field of constant research in the past decades, but there comes a point where the medium of information exchange must be updated to allow for further growth. Recent advancements in fields such as VR (Virtual Reality) have begun to foreshadow the next stage of the information revolution, beginning with a new medium to share information with a level of immersion that can hardly be imagined today.</p>

<p>To support an advancement of the information medium, a simple and accessible method to convert seamlessly between objects in the real world and those in the virtual world becomes of dire demand. 3D reconstruction is a field of computer vision that involves the “reconstruction” of 3D objects from 2D pictures. Examples of uses for 3D reconstruction include, generating 3D models of museum artifacts to share with the world, or increasing the reliability and efficiency of self-driving cars by generating models of the environment with greater accuracy.</p>

<h1 id="2-camera-calibration">2. Camera Calibration</h1>
<h2 id="21-motivation">2.1. Motivation</h2>

<p>Camera calibration is an important step in the 3D-reconstruction model and the primary focus of this research report. The role of camera calibration is to parameterize the internal properties and position/orientation of a given camera from the images that it takes. Additionally, camera lenses are necessarily flawed in their construction, and have varying degrees of optical distortion that can be modeled and accounted for through camera calibration. This research report details an implementation of the OpenCV (Open Source Computer Vision Library) camera calibration model, which involves matching 3D object points to their corresponding 2D image points, and optimizing several parameters based on the reprojection error.
 </p>
<h2 id="22-principles-of-camera-calibration">2.2. Principles of Camera Calibration</h2>

<h3 id="221-pin-hole-camera-model">2.2.1. Pin-hole Camera Model</h3>

<p>The pin-hole camera model is a theoretical camera model that enables a simple geometrical interpretation of the transformation between a world coordinate and its corresponding pixel coordinate. The pin-hole camera model consists of a sensor, a box, and a pinhole, and they are arranged as shown in figure 1. The sensor is represented by the plane between the camera and the object, and the pinhole is represented by the hole where the orange rays intersect.</p>

<p><img src="/assets/2025-5-28-3D-Reconstruction/figure1.png" alt="figure1" title="figure1" class="img-large-centered" /></p>
<div style="text-align: center;"> Figure 1: A graphic representation of the pin-hole model [1] </div>
<p><br /></p>

<h3 id="222-homogeneous-coordinates">2.2.2. Homogeneous Coordinates</h3>
<p>The homogeneous coordinate system is a coordinate system that is used primarily in computer vision and computer graphics, for its ability to express affine transformation and projective transformations with relative ease. This is because homogeneous coordinates can express points at infinity with finite coordinates [2]. In other words, they represent a ray through space with a single n+1 dimensional vector.
One would turn a n-dimensional vector into a homogeneous vector by appending a 1 as follows:</p>

\[\left[\begin{matrix}X\\Y\\Z\\\end{matrix}\right]\longrightarrow\left[\begin{matrix}X\\Y\\Z\\1\\\end{matrix}\right]\]

<p>Similarly, one would turn a (n+1)-dimensional homogeneous vector into a n-dimensional Cartesian vector by dividing all elements by the last element and removing the last element as follows:</p>

\[\left[\begin{matrix}X\\Y\\Z\\\end{matrix}\right]\longrightarrow\left[\begin{matrix}\frac{X}{Z}\\\frac{Y}{Z}\\\end{matrix}\right]\]

<h3 id="223-extrinsic-matrix">2.2.3. Extrinsic Matrix</h3>

<p>The extrinsic matrix of a picture represents the affine transformation of the 3D world coordinate system to the 3D camera coordinate system. The name extrinsic matrix implies that the values contained within the matrix are extrinsic to the camera and represents how the camera is situated in space.</p>

<p>Any camera’s pose, i.e. its position and orientation, can be represented by 3-dimensional rotation and translation. The transformation of a 3D homogeneous world coordinate $\left(X_w,Y_w,Z_w,\ 1\right)$ to its 3D camera coordinate $\left(X_c,Y_c,Z_c\right)$ is given by,</p>

\[\left[\begin{matrix}X_c\\Y_c\\Z_c\\\end{matrix}\right]=\left[\begin{matrix}r_{11}&amp;r_{12}&amp;r_{13}&amp;t_x\\r_{21}&amp;r_{22}&amp;r_{23}&amp;t_y\\r_{31}&amp;r_{32}&amp;r_{33}&amp;t_z\\\end{matrix}\right]\left[\begin{matrix}X_w\\Y_w\\Z_w\\1\\\end{matrix}\right].\]

<table>
  <tbody>
    <tr>
      <td>The extrinsic matrix is thus a joint rotation and transformation matrix $\left[R\middle</td>
      <td>t\right]$ given by equation (1), where $R$ is the rotational matrix and $t$ is the translation matrix representing the change in basis from the world coordinate to the camera coordinate.</td>
    </tr>
  </tbody>
</table>

\[\begin{equation}
\left[R\middle| t\right]=\left[\begin{matrix}r_{11}&amp;r_{12}&amp;r_{13}&amp;t_x\\r_{21}&amp;r_{22}&amp;r_{23}&amp;t_y\\r_{31}&amp;r_{32}&amp;r_{33}&amp;t_z\\\end{matrix}\right]
\end{equation}\]

<h3 id="224-intrinsic-matrix">2.2.4. Intrinsic Matrix</h3>

<p>The Intrinsic matrix of a given picture represents the transformation of the 3D camera coordinate system to the 2D pixel coordinate system. The name “intrinsic matrix” implies that the values within this matrix (intrinsic parameters) are characteristics of the camera that took the photo, and not dependent on external factors such as the location or orientation of the camera in the world coordinate system.</p>

<p>Figure 2 depicts the relationship between a 3D world coordinate $\left(X_w,Y_w,Z_w\right)$ and its corresponding 2D pixel coordinate $\left(u,v\right)$ in the pin-hole camera model.</p>

<p><img src="/assets/2025-5-28-3D-Reconstruction/figure2.png" alt="figure2" title="figure2" class="img-large-centered" /></p>
<div style="text-align: center;"> Figure 2: the relationship between a 3D world coordinate and a 2D pixel coordinate [3] </div>
<p><br /></p>

<p>When the principle point of the image sensor (i.e. the center of the image sensor) is given by $\left(c_x,c_y\right)$, and the 3D world coordinate is defined by the camera coordinate system, the 2D pixel coordinate $\left(u,v\right)$ of a given 3D camera coordinate $\left(X_c,Y_c,Z_c\right)$ is described by</p>

\[\begin{bmatrix} u \\ v \end{bmatrix}
= 
\begin{bmatrix} f_x \frac{X_c}{Z_c} + c_x  \\  f_y \frac{Y_c}{Z_c} + c_y \end{bmatrix}\]

<p>represented in practice as a matrix product of the form</p>

\[\left[\begin{matrix}u\\v\\1\\\end{matrix}\right]=\left[\begin{matrix}f_x&amp;0&amp;c_x\\0&amp;f_y&amp;c_y\\0&amp;0&amp;1\\\end{matrix}\right]\left[\begin{matrix}X_c\\Y_c\\Z_c\\\end{matrix}\right],\]

<p>where $\left[\begin{matrix}u&amp;v&amp;1\end{matrix}\right]^\top$ is a homogeneous representation of $\left[\begin{matrix}u&amp;v\end{matrix}\right]^\top$.</p>

<p>The intrinsic matrix $A$ is thus defined by matrix (2), where $f_x$ and $f_y$ represent the camera’s focal length in the x-direction and y-direction respectively, and $c_x$ and $c_y$ represent the camera’s principle point in x-coordinates and y-coordinates respectively.</p>

\[\begin{equation}
A=\left[\begin{matrix}f_x&amp;0&amp;c_x\\0&amp;f_y&amp;c_y\\0&amp;0&amp;1\\\end{matrix}\right]
\end{equation}\]

<h3 id="225-optical-distortion">2.2.5. Optical Distortion</h3>

<p>In camera calibration, it is typical to consider two types of optical distortion: radial and tangential distortions. Radial and tangential distortions are primarily caused by manufacturing inconsistencies that alter the shape of the lens. The effects of radial and tangential distortions are mitigated in the calibration process by altering the intrinsic matrix equation into equation (3).</p>

\[\begin{equation}
\left[\begin{matrix}u\\v\\\end{matrix}\right]=\left[\begin{matrix}f_xx^{\prime\prime}+c_x\\f_yy^{\prime\prime}+c_y\\\end{matrix}\right]
\end{equation}\]

<p>With</p>

\[\left[\begin{matrix}x^{\prime\prime}\\y^{\prime\prime}\\\end{matrix}\right] = \left[\begin{matrix}x^\prime\frac{1+k_1r^2+k_2r^4+k_3r^6}{1+k_4r^2+k_5r^4+k_6r^6}+2p_1x^\prime y^\prime+p_2\left(r^2+2x^{\prime2}\right)+s_1r^2+s_2r^4\\y^\prime\frac{1+k_1r^2+k_2r^4+k_3r^6}{1+k_4r^2+k_5r^4+k_6r^6}+p_1\left(r^2+2y^{\prime2}\right)+2p_2x^\prime y^\prime+s_3r^2+s_4r^4\\\end{matrix}\right],\]

\[\begin{align*}
r^2 &amp;= x^{\prime2}+y^{\prime2}, \\
\left[x^\prime,y^\prime\right] &amp;= \left[\frac{X_c}{Z_c},\frac{Y_c}{Z_c}\right].
\end{align*}\]

<p>Where, $k_1, k_2, k_3, k_4, k_5,$ and $k_6$ are the radial distortion coefficients; $p_1$ and $p_2$ are tangential distortions coefficients; and $s_1, s_2, s_3,$ and $s_4$ are the thin prism distortion coefficients.</p>

<h3 id="226-camera-matrix">2.2.6. Camera Matrix</h3>

<p>The final camera matrix is a matrix multiplication of the intrinsic and extrinsic matrices, and represented in equation (4), where s is a scale factor that adjusts for the unknown scale factor of the projective transformation.</p>

\[\begin{equation}
s\left[\begin{matrix}u\\v\\1\\\end{matrix}\right]=\left[\begin{matrix}f_x&amp;0&amp;c_x\\0&amp;f_y&amp;c_y\\0&amp;0&amp;1\\\end{matrix}\right]\left[\begin{matrix}r_{11}&amp;r_{12}&amp;r_{13}&amp;t_x\\r_{21}&amp;r_{22}&amp;r_{23}&amp;t_y\\r_{31}&amp;r_{32}&amp;r_{33}&amp;t_z\\\end{matrix}\right]\left[\begin{matrix}X_w\\Y_w\\Z_w\\1\\\end{matrix}\right]
\end{equation}\]

<p>Equation (4) can also be represented in the form,</p>

\[sp=A\left[R\middle| t\right]P_w,\]

<p>where $p$ is the pixel coordinate and $P_w$ is the world coordinate both represented in homogeneous coordinates.</p>

<h2 id="23-camera-calibration-from-a-checkerboard-pattern">2.3. Camera Calibration from a Checkerboard Pattern</h2>

<p>The standard method for camera calibration, and the method outlined in OpenCV’s documentation, involves taking pictures of a well-defined geometric pattern such as a chessboard and finding a transformation to map the 2-dimensional image points (pixel coordinates of the corners) to their known 3-dimensional object points (world coordinates of the corners).</p>

<p>The checkerboard pattern used in this method is shown in figure 3, which has 7 by 10 inner corners. The pattern was obtained as a pdf file from Mark Hedley Jones’s Calibration Checkerboard Collection [4] and printed onto standard A4 sized printing paper. 20 images were then taken from various angles with the Canon EOS R100 mounted with the Canon Lens EF 28 mm and the EF-EOS mount adapter, at a fixed focal length.</p>

<p><img src="/assets/2025-5-28-3D-Reconstruction/figure3.svg" alt="figure3" title="figure3" class="img-large-centered" /></p>
<div style="text-align: center;"> Figure 3: 8 by 11 checkerboard pattern with 7 by 10 inner corners [4]  

black and white when printed on paper </div>
<p><br /></p>

<p>Program 1 is a python script that was written with the OpenCV documentation [5] as reference, and takes in a directory of images in order to derive their image points and object points.</p>

<div style="text-align: center;"> Program 1: “findCorners” function definition </div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">findCorners</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">show</span><span class="p">):</span>
    <span class="c1"># assign object points
</span>    <span class="n">objp</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">objp</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">]].</span><span class="n">T</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">objpoints</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 3d objectpoints
</span>    <span class="n">imgpoints</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 2d image points
</span>    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1"># names of the image file
</span>
    <span class="c1"># get /*.JPG from specified directory
</span>    <span class="n">images</span> <span class="o">=</span> <span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="n">directory</span> <span class="o">+</span> <span class="s">'/*.JPG'</span><span class="p">)</span>  <span class="c1"># Specify the path to your images
</span>
    <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

        <span class="c1"># Find chessboard corners
</span>        <span class="n">ret</span><span class="p">,</span> <span class="n">corners</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">findChessboardCorners</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="c1"># If found, add object points, image points
</span>        <span class="k">if</span> <span class="n">ret</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">objpoints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">objp</span><span class="p">)</span>
            <span class="n">imgpoints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
            <span class="n">names</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

        <span class="c1"># display corners if specified
</span>        <span class="k">if</span> <span class="n">show</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">drawChessboardCorners</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
            <span class="n">cv2</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">'img'</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
            <span class="n">cv2</span><span class="p">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>

    <span class="n">cv2</span><span class="p">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>  
    <span class="k">return</span> <span class="n">names</span><span class="p">,</span> <span class="n">objpoints</span><span class="p">,</span> <span class="n">imgpoints</span>
</code></pre></div></div>

<p>The function in program 1, searches through a given directory for files with the “.JPG” extension and runs them through an OpenCV function called “findChessboardCorners”. This function effectively maps the known 3D coordinates of the chessboard corners to the 2D coordinate that they occupy in the given image. If corners are found, their pixel coordinate and world coordinates as well as the name of the image to which they belong, are stored in an array and are returned. Additionally, this information is passed to the “drawChessboardCorners” function where the detected chessboard corners are indicated on the image by dots, and their connections by lines. Figure 4 shows an example of a sample image (left) and its corresponding corner-indicated image (right).</p>

<p><img src="/assets/2025-5-28-3D-Reconstruction/figure4.png" alt="figure4" title="figure4" class="img-large-centered" /></p>
<div style="text-align: center;"> Figure 4: A sample image (left) and its corresponding corner-indicated image (right) </div>
<p><br /></p>

<p>The next step is to utilize the derived object points and image points to calculate the camera matrix. Program 2 is a python script that utilizes the OpenCV “calibrateCamera” function to take object and image points as inputs and produces several matrix arrays which are combined to make the camera matrix. The “savePoint” and “saveCalib” functions are used to save the image points, object points, and resulting camera matrices as NumPy files. Their definitions are shown in program 3.</p>

<div style="text-align: center;"> Program 2: camera calibration from image points and object points </div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Number of internal corners in the chessboard
</span><span class="n">DIMENSIONS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<span class="c1"># Current Directory 
</span><span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s">'batch1'</span>

<span class="c1"># get object points and image points
</span><span class="n">names</span><span class="p">,</span> <span class="n">objpoints</span><span class="p">,</span> <span class="n">imgpoints</span> <span class="o">=</span> <span class="n">findCorners</span><span class="p">(</span><span class="n">DIRECTORY</span><span class="p">,</span> <span class="n">DIMENSIONS</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Camera calibration
</span><span class="n">ret</span><span class="p">,</span> <span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">calibrateCamera</span><span class="p">(</span><span class="n">objpoints</span><span class="p">,</span> <span class="n">imgpoints</span><span class="p">,</span> <span class="n">RESOLUTION</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

<span class="c1"># save points and calibration
</span><span class="n">savePoint</span><span class="p">(</span><span class="n">DIRECTORY</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">objpoints</span><span class="p">,</span> <span class="n">imgpoints</span><span class="p">)</span>
<span class="n">saveCalib</span><span class="p">(</span><span class="n">DIRECTORY</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span><span class="p">)</span>
</code></pre></div></div>

<div style="text-align: center;"> Program 3: “saveCalib” and “savePoint” function definitions </div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">saveCalib</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">directory</span> <span class="o">+</span> <span class="s">'/calib.npy'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">np</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
        <span class="n">np</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
        <span class="n">np</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">mtx</span><span class="p">)</span>
        <span class="n">np</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
        <span class="n">np</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">)</span>
        <span class="n">np</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">tvecs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">savePoint</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">objpoints</span><span class="p">,</span> <span class="n">imgpoints</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">directory</span> <span class="o">+</span> <span class="s">'/point.npy'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">np</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
        <span class="n">np</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">objpoints</span><span class="p">)</span>
        <span class="n">np</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">imgpoints</span><span class="p">)</span>
</code></pre></div></div>

<p>An example of a calibration result is shown in figure 5. The x focal length and y focal length were calculated by converting the relevant intrinsic matrix component with the image sensor’s dimensions and pixel resolution, effectively converting the focal length given in pixel units to be given in mm units.</p>

<p><img src="/assets/2025-5-28-3D-Reconstruction/figure5.png" alt="figure5" title="figure5" class="img-large-centered" /></p>
<div style="text-align: center;"> Figure 5: the resulting intrinsic and extrinsic matrices of a camera calibration </div>
<p><br /></p>

<h2 id="24-visualizing-distortion-with-reprojection-error">2.4. Visualizing Distortion with Reprojection Error</h2>

<p>To estimate the accuracy of the calibration, the reprojection error is calculated. In fact, the OpenCV “calibrateCamera” function optimizes intrinsic, extrinsic, and distortion parameters by minimizing the reprojection error. By disabling the distortion parameter optimization in the “calibrateCamera” function and plotting the reprojection error, the effects of lens distortion can be visualized.</p>

<p>Reprojection error is calculated by taking the mean pixel distance between the 3D object points of the chessboard corners and the hypothetical projection of those corners to the image plane using the newly calculated camera matrix. By comparing where the corners are projected and where the corners should be, the accuracy of the transformation can be inferred. To obtain a visual representation of this process, program 4, based on the OpenCV documentation [5], draws exaggerated lines on the image to give a relative representation of reprojection error.</p>

<div style="text-align: center;"> Program 4: “reproject” function definition </div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reproject</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">objpoints</span><span class="p">,</span> <span class="n">imgpoints</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span><span class="p">,</span> <span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">show</span><span class="p">):</span>
    <span class="n">mean_error</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">line_scaler</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">objpoints</span><span class="p">)):</span>
         <span class="n">imgpoints2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">projectPoints</span><span class="p">(</span><span class="n">objpoints</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
         <span class="n">error</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">imgpoints</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">imgpoints2</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">NORM_L2</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">imgpoints2</span><span class="p">)</span>
         <span class="n">mean_error</span> <span class="o">+=</span> <span class="n">error</span>

         <span class="k">if</span> <span class="n">show</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c1"># Draw original and reprojected points
</span>            <span class="n">reprojected_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">pt_orig</span><span class="p">,</span> <span class="n">pt_proj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">imgpoints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">imgpoints2</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
                <span class="n">pt_len</span> <span class="o">=</span> <span class="p">[</span> <span class="n">pt_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt_proj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pt_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">line_scaler</span><span class="p">,</span> 
<span class="n">pt_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt_proj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pt_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">line_scaler</span> <span class="p">]</span>
                <span class="n">cv2</span><span class="p">.</span><span class="n">circle</span><span class="p">(</span><span class="n">reprojected_img</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pt_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">pt_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="mi">20</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">cv2</span><span class="p">.</span><span class="n">line</span><span class="p">(</span><span class="n">reprojected_img</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pt_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">pt_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> 
<span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pt_len</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">pt_len</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>

            <span class="n">cv2</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">'Reprojected'</span><span class="p">,</span> <span class="n">reprojected_img</span><span class="p">)</span>
            <span class="n">cv2</span><span class="p">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">cv2</span><span class="p">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mean_error</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">objpoints</span><span class="p">)</span>
</code></pre></div></div>

<p>Looping through each of the images, the OpenCV function “reprojectPoints” is used to project object points to the image plane, and the “norm” function is used to calculate the absolute distance between the image points and the projected points. Circles are drawn around the image points, and lines are drawn to the projected points, with their lengths scaled by 50 pixels to make them easily visible.</p>

<p>The two images shown in figure 6, are examples of images that have been calibrated with distortion correction disabled. The image on the left is an example of a good reprojection, and a particularly good example of positive radial distortion, a type of lens aberration where the image seems to bulge towards the lens and points are projected farther from the center than they should be. The lines in the left image indicate that the projected points were generally closer to the center than the actual image points, which would fall in line with the properties of positive radial distortion. Additionally, radial distortion has a tendency for the reprojection errors to become larger the farther they are from the center of the image, which can generally be seen in both images.</p>

<div class="image-row-two">
  <div class="image-column-two">
    <img src="/assets/2025-5-28-3D-Reconstruction/figure6left.png" alt="" />
  </div>
  <div class="image-column-two">
    <img src="/assets/2025-5-28-3D-Reconstruction/figure6right.png" alt="" />
  </div>
</div>

<div style="text-align: center;"> Figure 6: Reprojection error with distortion correction disabled </div>
<p><br /></p>

<p>Enabling the “calibrateCamera” distortion correction, reprojecting the images again gives the images shown in figure 7. It can be noted that the reprojection errors have been significantly reduced.</p>

<div class="image-row-two">
  <div class="image-column-two">
    <img src="/assets/2025-5-28-3D-Reconstruction/figure7left.png" alt="" />
  </div>
  <div class="image-column-two">
    <img src="/assets/2025-5-28-3D-Reconstruction/figure7right.png" alt="" />
  </div>
</div>

<div style="text-align: center;"> Figure 7: Reprojection error with distortion correction enabled </div>
<p><br /></p>

<h2 id="25-plotting-camera-pose-from-calibration-parameters">2.5. Plotting Camera Pose from Calibration Parameters</h2>

<p>To ensure that there are no obvious issues with the extrinsic parameters, it is useful to derive the camera pose from the extrinsic parameters and plot them in a 3D coordinate system. The derivation of this transformation begins with a reconfirmation of the relationship between the world coordinate system and the camera coordinate system in the current model. The extrinsic matrix is a joint rotation-translation matrix which is broken down as follows,</p>

\[\left[\begin{matrix}X_c\\Y_c\\Z_c\\\end{matrix}\right]=\left[\begin{matrix}r_{11}&amp;r_{12}&amp;r_{13}\\r_{21}&amp;r_{22}&amp;r_{23}\\r_{31}&amp;r_{32}&amp;r_{33}\\\end{matrix}\right]\left[\begin{matrix}X_w\\Y_w\\Z_w\\\end{matrix}\right]+\left[\begin{matrix}t_x\\t_y\\t_z\\\end{matrix}\right].\]

<p>For simplicity, the rotation matrix is represented as R and the translation vector is represented as t. The world coordinate is the unknown, so it is rewritten as P_W, and the camera coordinate is rewritten as the camera’s position in the camera coordinate system, the origin, and thus the zero vector 0. Therefore, the new expression is written as</p>

\[\mathbf{0}=RP_W+t,\]

<p>Which is simplified to</p>

\[P_W=-R^{-1}t.\]

<p>Here, the fact that for a rotation matrix $R$, its inverse $R^{-1}$ and its transpose $R^\top$ are the same matrix is used to further simplify the above equation into expression (5).</p>

\[\begin{equation} P_W=-R^\top t \end{equation}\]

<p>With expression (5), the camera pose for a given extrinsic matrix can be calculated trivially and plotted with an extension such as matplotlib. Program 5 shows the implementation of this method in python.</p>

<div style="text-align: center;"> Program 5: python file to plot camera pose on a 3D matplotlib graph </div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">mpl_toolkits.mplot3d.art3d</span> <span class="k">as</span> <span class="n">art3d</span>

<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>
<span class="kn">from</span> <span class="nn">matplotlib.transforms</span> <span class="kn">import</span> <span class="n">Affine2D</span>

<span class="kn">from</span> <span class="nn">definitions</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">BOARD</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="n">names</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span> <span class="o">=</span> <span class="n">loadCalib</span><span class="p">(</span><span class="s">'batch1'</span><span class="p">)</span>

<span class="c1"># instantiate figure
</span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">()</span>

<span class="c1"># instantiate axis
</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">axes</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s">'3d'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">])</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">])</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_zlim</span><span class="p">([</span><span class="mi">0</span>  <span class="p">,</span> <span class="mi">40</span><span class="p">])</span>

<span class="c1"># Draw the checkerboard on the floor
</span><span class="n">p</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">BOARD</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">BOARD</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="p">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="n">art3d</span><span class="p">.</span><span class="n">pathpatch_2d_to_3d</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">zdir</span><span class="o">=</span><span class="s">"z"</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rvecs</span><span class="p">)):</span>
    <span class="c1"># rodrigues rotation vector to rotation matrix
</span>    <span class="n">R</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">Rodrigues</span><span class="p">(</span><span class="n">rvecs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="c1"># find the camera center
</span>    <span class="n">C</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="n">tvecs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="c1"># print the basis vectors of the camera coordinate system
</span>    <span class="n">ax</span><span class="p">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s">"red"</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s">"green"</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s">"blue"</span><span class="p">)</span>
    
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p>The resulting camera pose graph can be seen in figure 8, where the basis vector in blue represents the z-axis of the camera coordinate system, and thus the direction of the camera in 3D space. Additionally, the blue square at the bottom of the graph represents the chessboard pattern in 3D space.</p>

<p><img src="/assets/2025-5-28-3D-Reconstruction/figure8.png" alt="figure8" title="figure8" class="img-large-centered" /></p>
<div style="text-align: center;"> Figure 8: camera pose derived from the 14 extrinsic parameters of batch 1 </div>
<p><br /></p>

<p>It can be observed that the camera poses are all pointing towards the chessboard pattern, and further examination reveals that their positions and orientations seem to match the expected camera poses of the individual images. The first batch of sample images has been highlighted in detail within this report, but other samples such as the 3 samples shown in figure 9, were also taken to determine the quantitative effects of altering the focal lengths on the camera’s intrinsic matrix. As the focal lengths increase from left to right in figure 9, it was necessary to take the images farther from the checkerboard pattern in order to retain focus, which seems to be depicted with great accuracy in the resulting camera poses.</p>

<div class="image-row-three">
  <div class="image-column-three">
    <img src="/assets/2025-5-28-3D-Reconstruction/figure9left.png" alt="" />
  </div>
  <div class="image-column-three">
    <img src="/assets/2025-5-28-3D-Reconstruction/figure9mid.png" alt="" />
  </div>
  <div class="image-column-three">
    <img src="/assets/2025-5-28-3D-Reconstruction/figure9right.png" alt="" />
  </div>
</div>

<div style="text-align: center;"> Figure 9: camera pose derived from extrinsic parameters with focal length 0.5, 0.75, 1.0 from left to right </div>
<p><br /></p>

<h1 id="3-3d-reconstruction-from-video">3. 3D Reconstruction from Video</h1>
<h2 id="31-motivation">3.1. Motivation</h2>

<p>The need to convert seamlessly between the real and virtual world is not just a concern for professionals, and can be expected to play an important role in the everyday lives of ordinary people. However, a challenge arises in the difficulty of collecting sample data, as current 3D reconstruction techniques require specific and expensive equipment that would be unfeasible to implement at the consumer level. Further advancement of 3D reconstruction methods must also entail an increase in their accessibility and ease of use.</p>

<p>One implication of technological advancements in recent years is that, although the ordinary person may not have a high-end digital camera, the ordinary person is increasingly likely to have a smartphone. Additionally, videos can be seen as a discrete array of images. Thus, a new method to conduct 3D reconstruction by extracting the non-blurry frames from a video of an object taken with a smartphone, is considered in this report. Considering that videos generally have around 30 to 60 frames per second, the difference between adjacent frames is typically insignificant in the context of SFM (Structure from Motion). Additionally, videos use auto focus to maintain focus on a subject, but their control systems are typically based off of feedback systems and have latencies and result in an uneven distribution of focus throughout the frames of a video. A consequence of this is that most frames in a video with motion are blurry. Although this is not a concern when played back with real time speed, a blurry image for 3D reconstruction implies that the resulting point cloud contains uncertainty. Depending on its severity, the algorithm may decide that the point is too uncertain to even plot. Although 3D reconstruction is not conducted in this report, a method to extract the non-blurry frames from an image using Laplacian blur detection is explored.</p>

<h2 id="32-sampling-images-from-a-video">3.2. Sampling Images from a Video</h2>

<p>There are two main methods for detecting if a given image is blurry. The first method involves comparing the variance of images that have been converted to gray scale and ran through a Laplacian filter. Details of this method are given in section 2.2.1. The second method involves comparing the magnitude spectrums of images that have undergone a Fourier transform, and determining the ratio of high to low-frequency components of the image. This method is not discussed or implemented in this research.</p>

<h3 id="321-laplacian-variance-method">3.2.1. Laplacian Variance Method</h3>

<p>The Laplacian filter is a convolution filter that can be described as a discrete second-order derivative of an input image. The Laplacian filter is typically used as a method to quantitatively describe regions of rapid intensity change in an image, making it an ideal fit for edge-detection applications. Because the primary distinction between blurry and non-blurry images are the sharpness of their edges, the Laplacian filter can also be used to describe the relative blurriness of an image. In particular, the variance of an image that has been passed through the Laplacian filter can be used to compare the level of blur between similar images. It is important to consider however, that the Laplacian variance is only meaningful when taken with respect to images of similar composition, as this method is, for instance, incapable of distinguishing between sharp but monotone images and unsharp but colorful images.</p>

<p>The Laplacian filter method described in the OpenCV documentation [6] uses a 3 by 3 convolution kernel of the form</p>

\[\left[\begin{matrix}0&amp;1&amp;0\\1&amp;-4&amp;1\\0&amp;1&amp;0\\\end{matrix}\right].\]

<p>The implementation is given in program 6. The “GetVar” function takes an image as an input, converts the image to gray scale and returns Laplacian variance by using the OpenCV “cv2.Laplacian()” function and calling the NumPy “var()” method on the resulting NumPy array. The “GetLaplacians” function takes the path to a video and an output folder as inputs and calculates the Laplacian variance of each frame in a video, storing the resulting values in a NumPy file.</p>

<div style="text-align: center;"> Program 6: “GetVar” and “GetLaplacian” function definitions </div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">GetVar</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
    <span class="n">laplacian_var</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">Laplacian</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">CV_64F</span><span class="p">).</span><span class="n">var</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">laplacian_var</span>

<span class="k">def</span> <span class="nf">GetLaplacians</span><span class="p">(</span><span class="n">video_path</span><span class="p">,</span> <span class="n">output_folder</span><span class="p">):</span>
    <span class="n">laplacians</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cap</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">VideoCapture</span><span class="p">(</span><span class="n">video_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cap</span><span class="p">.</span><span class="n">isOpened</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Error: Could not open video </span><span class="si">{</span><span class="n">video_path</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">ret</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">laplacians</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">GetVar</span><span class="p">(</span><span class="n">frame</span><span class="p">))</span>
    <span class="n">cap</span><span class="p">.</span><span class="n">release</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_folder</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">np</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">laplacians</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="322-filtering-laplacian-variance-for-optimal-image-selection">3.2.2. Filtering Laplacian Variance for Optimal Image Selection</h3>

<p>Program 6 produces a NumPy array that contains the Laplacian variance values of each frame in a video. The next step is to find a method to optimally select images based on these values. As mentioned previously, the Laplacian variance values themselves have no inherent meaning, and only have meaning relative to the values of adjacent frames. Thus, simply selecting the top N highest Laplacian variance values from a video will not necessarily produce good results. Additionally, the images that are selected in this process are ultimately used in SFM, where adjacent frames should be relatively near each other in order to effectively find correspondences between them. It is thus, also important to consider the interval of the selected frames for optimal results. The three main filters proposed in this research are the Decay Filter, the Moving Maximum Filter, and the Local Maxima Filter.</p>

<h3 id="323-decay-filter">3.2.3. Decay Filter</h3>

<p>Program 7 shows the implementation of the decay filter. The decay filter takes a threshold and a decay constant as inputs. The search begins by setting the moving threshold to the input threshold. Looping through all elements of the array, while the current value does not meet the threshold, the threshold is decreased by the decay constant, and the next value is checked. When a value that meets the threshold is found, the moving threshold is set back to the initial input threshold, and the process is repeated.</p>

<div style="text-align: center;"> Program 7: “DecayFilter” function definition </div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">DecayFilter</span><span class="p">(</span><span class="n">laplacians</span><span class="p">,</span> <span class="n">blur_threshold</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span> <span class="n">decay_per_cycle</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">blur_threshold</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">laplacians</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">threshold</span><span class="o">&lt;</span><span class="n">laplacians</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span> 
            <span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">laplacians</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">blur_threshold</span> <span class="k">if</span> <span class="n">threshold</span><span class="o">&lt;</span><span class="n">laplacians</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="n">threshold</span> <span class="o">-</span> <span class="n">decay_per_cycle</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</code></pre></div></div>

<p>A benefit of the decay filter is that the intervals of selected frames are relatively easy to control. With fine tuning and ideal conditions, the decay filter can be described as a filter that prioritizes tight control on the interval between frames, and compromises for a pseudo interval maximum. The biggest flaw with the decay filter is that it compromises with an interval maximum, meaning it does not necessarily consider the local context of the value, and merely selects them based on their height. It is also not a full interval maximum filter because it selects frames based on an arbitrary decay cycle, meaning it does not necessarily select the highest value in a given interval.</p>

<p>The decay filter with threshold 100 and decay constant 0.5, applied to a 3 second demonstration video is shown in figure 10. The horizontal axis is the frame, and the vertical axis is the corresponding Laplacian variance. It is to be noted that an initial threshold of 100 is likely too high for this sample, but the equally large decay constant makes for a good demonstration of the decay filter’s interval consistency.</p>

<p><img src="/assets/2025-5-28-3D-Reconstruction/figure10.svg" alt="figure10" title="figure10" class="img-large-centered" /></p>
<div style="text-align: center;"> Figure 10: Laplacian variance by frame overlayed with decay filter selection in red </div>
<p><br /></p>

<h3 id="324-moving-maximum-filter">3.2.4. Moving Maximum Filter</h3>

<p>Program 8 shows the implementation of the moving maximum filter. The moving maximum filter takes a block size as input, and moves this block throughout the array, always selecting the largest value in the block. Like the moving average, the moving maximum filter soothes a large discontinuous array into a relatively continuous array. In the case of the moving maximum filter, the individual Laplacian variance values are smoothed into a function that represents the local ceiling values.</p>

<div style="text-align: center;"> Program 8: “MovingMaximumFilter” function definition </div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">MovingMaximumFilter</span><span class="p">(</span><span class="n">laplacians</span><span class="p">,</span> <span class="n">blockSize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">laplacians</span><span class="p">)</span><span class="o">-</span><span class="n">blockSize</span><span class="p">):</span>
        <span class="n">splice</span> <span class="o">=</span> <span class="n">laplacians</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">blockSize</span><span class="p">]</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">max</span><span class="p">(</span><span class="n">splice</span><span class="p">)</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">splice</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">arg</span><span class="p">):</span> 
            <span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">arg</span><span class="p">,</span> <span class="nb">max</span><span class="p">])</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">arg</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</code></pre></div></div>

<p>Program 8 loops through the values of the array and finds the maximum value in a splice of length “blockSize” starting from the current index. If this value has not yet been selected, it is appended to an array which is retuned at the end of the function. Thus, for large block sizes such as 10, it is normal for the same point to be selected multiple times. The benefit of the moving maximum filter is that it is a full interval maximum filter, meaning that it always selects the highest value in a given interval. However, to reiterate, the highest value does not necessarily indicate the sharpest frame, and therefore it is necessary to pick a block size that strikes a fine balance between the locality necessary for making the variance values meaningful, and the generality that is necessary to create a meaningful distinction from the local maxima filter that will be covered next. In one sentence, the moving maximum filter carries over the decay filter’s constant interval property, but also implements a full interval maximum filter unlike the decay filter.</p>

<p>The same 3 second demonstration video was filtered through a moving maximum filter with the block size set to 10, and the results are shown in figure 11. It can be observed that the moving maximum filter generally selects ideal values, but there are areas where needless selections occur, and others where perfectly good candidates are ignored because of their higher neighbors.</p>

<p><img src="/assets/2025-5-28-3D-Reconstruction/figure11.svg" alt="figure11" title="figure11" class="img-large-centered" /></p>
<div style="text-align: center;"> Figure 11: Laplacian variance by frame overlayed with moving maximum filter selections in red </div>
<p><br /></p>

<h3 id="325-local-maxima-filter">3.2.5. Local Maxima Filter</h3>

<p>Program 9 shows the implementation of the local maxima filter. If the two adjacent array elements are both less than the current array element, the value is selected.</p>

<div style="text-align: center;"> Program 9: “LocalMaximaFilter” function definition </div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">LocalMaximaFilter</span><span class="p">(</span><span class="n">laplacians</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span>  <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">laplacians</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">laplacians</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">laplacians</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">laplacians</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">laplacians</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">laplacians</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</code></pre></div></div>

<p>The local maxima filter is likely to be the best method for this application because it follows the principles of auto focus in smartphone videos. Video auto focus in many smartphone cameras rely on passive feedback to constantly adjust the focus based on the previous frame, and thus include an inherent latency. In most videos, motion of an object or motion of the camera induces a pattern of, relatively in focus, relatively out of focus, relatively in focus, and so on… An example of this effect is shown in figure 12, where three adjacent frames and their Laplacian variances are displayed.</p>

<p><img src="/assets/2025-5-28-3D-Reconstruction/figure12.png" alt="figure12" title="figure12" class="img-large-centered" /></p>
<div style="text-align: center;"> Figure 12: Auto focus for video has the tendency to alternate between focused and non-focused frames </div>
<p><br /></p>

<p>The benefit of the local maxima filter is its ability to select all the points in relative focus. However, selecting all points relative to their neighbors can simultaneously be hazardous as very blurry photos that are locally non-blurry can easily be selected on accident.
The 3 second demonstration video was filtered through the local maxima filter and the results are shown in figure 13. It can be observed that several points with insignificant local maxima have also been selected.</p>

<p><img src="/assets/2025-5-28-3D-Reconstruction/figure13.svg" alt="figure13" title="figure13" class="img-large-centered" /></p>
<div style="text-align: center;"> Figure 13: Laplacian variance by frame overlayed with local maxima filter selections in red </div>
<p><br /></p>

<h2 id="33-comparing-the-results">3.3. Comparing the Results</h2>

<p>This section shows the results of a comparison between frames that were selected by the local maxima filter and those that were not selected. Figure 14 shows 4 frames that were selected from a longer 45 second video, and Figure 15 shows 4 frames that were not selected from the same video. Samples were taken randomly from the same frame range.</p>

<p><img src="/assets/2025-5-28-3D-Reconstruction/figure14.png" alt="figure14" title="figure14" class="img-large-centered" /></p>
<div style="text-align: center;"> Figure 14: frames selected by the local maxima filter  </div>
<p><br /></p>

<p><img src="/assets/2025-5-28-3D-Reconstruction/figure15.png" alt="figure15" title="figure15" class="img-large-centered" /></p>
<div style="text-align: center;"> Figure 15: frames not selected by the local maxima filter </div>
<p><br /></p>

<p>It can be noted with some close inspection that the frames that were not selected by the local maxima filter are generally all blurry, while those that were selected by the filter can occasionally be blurry. It can be concluded from these results that the local maxima filter is relatively not selective, resulting in a tendency for false positives. On the other hand, the highly non-selective nature of the filter ensures that almost all of the non-blurry frames are indeed selected. This is a good result, as applying a second filter to further refine the results and discard the false positives becomes a possibility.
 </p>
<h1 id="4-conclusion">4. Conclusion</h1>

<p>In conclusion, as the amount and the quality of the information we share with the world continues to change and grow, the ways in which we convey them, the information medium, is also expected to change and grow. A direct consequence of this is that the demand for a means to convert between the real world and the virtual world increases rapidly. One way to potentially meet this demand is to introduce new technologies that increase the accessibility of 3D reconstruction models. This report suggested a new approach to select relatively good frames from a smartphone video, and detailed an implementation of the OpenCV camera calibration model which is a critical component of the 3D reconstruction pipeline.</p>

<h1 id="5-references">5. References</h1>

<p>[1]. MathWorks, “カメラキャリブレーションとは”, https://jp.mathworks.com/help/vision/ug/camera-calibration.html, Accessed: 7/2/24</p>

<p>[2]. Stanford University, “Homogeneous Coordinates”, https://ai.stanford.edu/~birch/projective/node4.html, Accessed: 6/21/24</p>

<p>[3]. OpenCV, “Camera Calibration and 3D Reconstruction”, https://docs.opencv.org/4.x/d9/d0c/group__calib3d.html, Accessed: 6/21/24</p>

<p>[4]. Mark Hadley Jones, “Calibration Checkerboard Collection”, https://markhedleyjones.com/projects/calibration-checkerboard-collection, referenced 5/10/2024</p>

<p>[5]. OpenCV, “Camera Calibration”, https://docs.opencv.org/4.x/dc/dbb/tutorial_py_calibration.html, Accessed: 6/21/24</p>

<p>[6]. OpenCV, “Image Filtering”, https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad78703e4c8fe703d479c1860d76429e6, Accessed: 8/2/24</p>]]></content><author><name>武藤皐蘭</name></author><category term="projects" /><summary type="html"><![CDATA[Some would say that we are currently living through the information age, a universal turning point for civilization which has the potential to rival the agricultural and industrial revolution in terms of societal impact. One important aspect of the information age is that it has enabled the sharing of information with far less work and with far more accessibility than in the past. The invention of the internet and its advancement as a global exchange for information has undoubtedly raised the bar for the collective intelligence of mankind. Increasing the amount of information that can be stored and transferred has been a field of constant research in the past decades, but there comes a point where the medium of information exchange must be updated to allow for further growth. Recent advancements in fields such as VR (Virtual Reality) have begun to foreshadow the next stage of the information revolution, beginning with a new medium to share information with a level of immersion that can hardly be imagined today.]]></summary></entry><entry><title type="html">C89コンパイラのパーサをCで実装</title><link href="http://localhost:4000/projects/C89-Parser/" rel="alternate" type="text/html" title="C89コンパイラのパーサをCで実装" /><published>2025-05-28T00:00:00+09:00</published><updated>2025-05-28T00:00:00+09:00</updated><id>http://localhost:4000/projects/C89-Parser</id><content type="html" xml:base="http://localhost:4000/projects/C89-Parser/"><![CDATA[<p>プログラムに携わるエンジニアとしてコンパイラは当然のように使う道具である。ただし、その裏には人間の意思を機械が実行できる指示に変換するための奥深い技術がある。また、コンパイラを勉強することによって、コンパイルエラーの処理能力が強化されたり、その言語の理解度が深まるといった利点が挙げられる。当然のように使う道具への感謝意識を持つことも技術者として大切なように思える。</p>

<p>本記事では、近代の情報技術の著しい発展の基盤となるコンパイラを解明し、C89コンパイラの解析部分の一部をC言語で実装した過程を示す。流れとしては、2章でコンパイラの概要を説明し、3章で重要な補足としてBNF（Backus-Naur form）を説明したのち、4章から6章にかけてコンパイラの解析部分を実際のコードとともに解説し、7章で実際に入力テストを通してパーサーを検証する。</p>

<h1 id="2-コンパイラの概要">2. コンパイラの概要</h1>

<p>コンパイラはその言語の規則に従って書かれた文字列を機械語に変換する、いわば翻訳プログラムである。図1で示すコンパイラの構造は、おおよそ「解析部分」と「変換部分」に分けて考えることができる。コンパイラの解析部分では、入力コードの文字列を解析して意味を抽出する。解析部分に含めている最適化では、抽出された意味をもって最適な形に変換する。最後に変換部分では、抽出かつ最適化された意味から機械語を生成し、リンキング段階でライブラリや関連ファイルを結合させ、実行可能な機械語を出力する。本レポートでは解析部分の字句解析と構文解析の実装について解説する[1]。</p>

<p><img src="/assets/2025-5-28-C89-Parser/figure1.svg" alt="figure1" title="figure1" class="img-large-centered" /></p>
<div style="text-align: center;"> 図1：コンパイラの構造 </div>
<p><br />
 
プログラミング言語はあらゆる言語と同様に、字句と文法によって規定される。字句は言語を構成する最小の単位をなし、文法は字句の規則正しい繋がりを共有するルールである。図1の「字句解析」は入力されたコードから、意味をなす最小の単位である、人間言語でいう単語を抽出する役割がある。この際に、余計なスペースや解析不要なコメントなどを読み飛ばす。「構文解析」では抽出した字句の繋がりを文法規定に当てはめ、初めて指示として意味をなす、人間言語でいう「文」として解釈する役割がある。この際に、コードの意味を最簡な形で表す「抽象構文木」を同時に作成する。「意味解析」では、構文解析で生成した抽象構文木を用いて,型検査などの構文を超越して、人間言語における文章レベルで意味の確認を行う[1]。</p>

<p>ここで重要な注意点として、コンパイラを実装する一つ目の難しさは、ユーザーが誤った入力をする可能性である。字句解析の段階では許容される字句から構成されていること、構文解析の段階では許容される文法に当てはまること、を全ての字句と文法ルールについて確認する必要がある。これについては4章と5章で詳しく解説する。</p>

<h1 id="3-bnfbackusnaur-form">3. BNF（Backus–Naur form）</h1>
<p>コンパイラを実装する二つ目の難しさは文法の複雑さである。そこで、コンピュータ言語の文法記述はBNF（Backus-Naur form）という表記法を用いて表すことにする。BNFには様々な種類や標準があるが、本レポートで扱うBNFは表1の記号からなるものとする。</p>

<div style="text-align: center;"> 表1：本レポートで用いるBNF表記法 </div>

<table>
  <thead>
    <tr>
      <th>記号</th>
      <th>説明</th>
      <th>範囲</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>::=</td>
      <td>左辺を右辺で定義する</td>
      <td> </td>
    </tr>
    <tr>
      <td>&lt;&gt;</td>
      <td>中に名前を入れて変数を表す</td>
      <td> </td>
    </tr>
    <tr>
      <td>{}</td>
      <td>普通の括弧のように使う</td>
      <td> </td>
    </tr>
    <tr>
      <td>|</td>
      <td>どちらかを選択する（OR）</td>
      <td> </td>
    </tr>
    <tr>
      <td>*</td>
      <td>前の要素は何回でも繰り返していい</td>
      <td>“{0, }”</td>
    </tr>
    <tr>
      <td>+</td>
      <td>前の要素は1回以上の繰り返しを許す</td>
      <td>“{1, }”</td>
    </tr>
    <tr>
      <td>?</td>
      <td>前の要素は0か1回の繰り返しを許す</td>
      <td>“{0, 1}”</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>例えば、本レポートで使うC89のBNF [2] はプログラム1のように始まる。プログラム1を読み解くと、「translation-unit」は「external-declaration」を何回でも繰り返したもので定義される。また、「external-declaration」は「function-definition」もしくは「declaration」と定義されている。</p>

<div style="text-align: center;"> プログラム1：C89のBNFの非終端要素の例 [2] </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;translation-unit&gt; ::= {&lt;external-declaration&gt;}*

&lt;external-declaration&gt; ::= &lt;function-definition&gt;
                         | &lt;declaration&gt;
</code></pre></div></div>

<p>プログラム1で示す「translation-unit」と「external-declaration」はいずれも非終端要素を表していると言える。一方でプログラム2で示すような「storage-class-specifier」は字句のみから構成されている。文法は必ず字句に帰着するため、これらの要素は終端要素であることがわかる。</p>

<div style="text-align: center;"> プログラム2：C89のBNFの終端要素の例 [2] </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;storage-class-specifier&gt; ::= auto
                            | register
                            | static
                            | extern
                            | typedef
</code></pre></div></div>

<p>最後にプログラム3で示す「pointer」の定義は自分自身を含んでいることがわかる。このようにBNFを再帰的に記述することによって簡潔に文法を記述することができる。</p>

<div style="text-align: center;"> プログラム3：C89のBNFの再帰例 [2] </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;pointer&gt; ::= * {&lt;type-qualifier&gt;}* {&lt;pointer&gt;}?
</code></pre></div></div>

<h1 id="4-字句解析lexical-analysis">4. 字句解析（Lexical Analysis）</h1>
<h2 id="41-設計">4.1. 設計</h2>

<p>字句解析の目的は人間言語における単語をコードの文字列から抽出することであると説明した。例えば、プログラム4のC言語プログラムは九つのトーケン「int」「x」「=」「3」「,」「y」「=」「4」「;」からなっている。また、意味的には型指定子の「int」、変数名「x」「y」、等式「=」、定数「3」「4」、コンマ「,」、とセミコロン「;」からなっている。</p>

<div style="text-align: center;"> プログラム4：C言語の具体例 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div></div>

<p>次に、プログラム4と同値なものをプログラム5で示す。つまり、スペースや改行を考慮する必要はなく、トーケンの順番のみでプログラムの意味が決まる。よって、これらのトーケンを先頭から読み込んではリストに追加していく方針をとる。ただし、プログラム6で示すように、変数名「intvariable」などを先頭から素朴に読み込むと「int」「variable」の様に分割して解釈される。つまり、型指定子などのキーワードに続いて変数名に使用可能な文字があれば、変数名として解釈する必要がある。</p>

<div style="text-align: center;"> プログラム5：スペースや改行が入っても同じ意味で解釈される </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>      <span class="n">x</span>  <span class="o">=</span> <span class="mi">3</span>     
<span class="p">,</span><span class="n">y</span> <span class="o">=</span>    <span class="mi">4</span><span class="p">;</span>
</code></pre></div></div>

<div style="text-align: center;"> プログラム6：型指定子などのトーケン化における性質 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">intvariable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intvariable</span><span class="p">;</span>
</code></pre></div></div>

<p>読み込んでいくトーケンは単方向リストとして保管し、各ノードにトーケンの構文的な意味を表す列挙型整数と、トーケンが定数の場合にその型を表す列挙型整数を備える。ここでいうトーケンの構文的な意味とは、BNFに含まれるトーケンを終端要素ごとにまとめたものである。つまり、プログラム7の「struct-or-union」という終端要素をそのままプログラム8の列挙型「l_Types」の要素とする。また、単方向リスト「Token」を構造体で管理した、おおよその構造を図2で示す。</p>

<div style="text-align: center;"> プログラム7：BNFの終端要素「struct-or-union」[2] </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;struct-or-union&gt; ::= struct
                    | union
</code></pre></div></div>

<div style="text-align: center;"> プログラム8：列挙型「l_Types」の要素「struct_or_union」 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">l_Types</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">struct_or_union</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span>
    <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<p><img src="/assets/2025-5-28-C89-Parser/figure2.svg" alt="figure2" title="figure2" class="img-large-centered" /></p>
<div style="text-align: center;"> 図2：構造体「Token」の構成 </div>
<p><br /></p>

<p>ここで大事な注釈が二つある。一つ目は複数の意味を持つトーケンは単独の列挙型整数を割り当てることで、二つ目はトーケンの読み込みには順序を設ける必要があることである。「<em>」の様なトーケンは掛け算の意味とポインタ指定子の意味を同時に持つため、文脈で判断する必要がある。この判断は構文解析で行うことにして、字句解析の段階では「dot」として識別する。また、プログラム9で示す様に「assignment-operator」は様々な代入演算子を持っているが、例えば「</em>」を先に読み込んでしまうと「<em>=」が「</em>」「=」と解釈されてしまう問題点がある。基本的に「assignment-operator」の様な、より長いトーケンを先に読み込むことによってこの問題を回避できる。</p>

<div style="text-align: center;"> プログラム9：BNFの「assignement-operator」[2] </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;assignment-operator&gt; ::= =
                            | *=
                            | /=
                            | %=
                            | +=
                            | -=
                            | &lt;&lt;=
                            | &gt;&gt;=
                            | &amp;=
                            | ^=
                            | |=
</code></pre></div></div>

<h2 id="42実装">4.2.実装</h2>
<p>まずmainから実装し、トップダウンにプログラムを作成していく。プログラム10では理想的な字句解析の呼び出しを示している。Mainの標準引数としてコンパイル対象のファイルを受け取り、字句を保管するトーケン構造体を初期化する。字句解析は行ごとに実行し、字句解析がエラーを返したら行を特定して標準出力に返す。これを実現するために、「Token」というリスト構造体と、「lex()」というトーケンリスト及び各行の文字列を引数とした字句解析関数を実装する。</p>

<div style="text-align: center;"> プログラム10：mainの字句解析処理 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// 入力ファイルの受付</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"invalid arguments</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;}</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"unable to open file</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span> 
    <span class="c1">// トーケンの作成</span>
    <span class="n">Token</span><span class="o">*</span> <span class="n">tokens</span>  <span class="o">=</span> <span class="n">construct</span><span class="p">();</span>
    <span class="c1">// コードファイルを行ごとに字句解析</span>
    <span class="kt">int</span> <span class="n">line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">FILE_LINE_LENGTH</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">line</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">// ファイルから読み込んだ行の改行文字を終端文字で置き換える</span>
        <span class="n">buffer</span><span class="p">[</span><span class="n">strcspn</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="c1">// 字句解析を行に施して、エラーが返されたら終了した行番号とともに標準出力</span>
        <span class="k">if</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">buffer</span><span class="p">))</span> <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"lexical error at line %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span> <span class="k">goto</span> <span class="n">E</span><span class="p">;}</span>
    <span class="p">}</span>
    <span class="err">\</span><span class="n">vdots</span>
<span class="nl">E:</span>  <span class="c1">// ファイルを閉じる</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>「Token」は文字列と二つの整数を持つ単方向リストとして実装する。この実装テンプレートをプログラム11で示す。付随する関数として、コンストラクタ「constructor()」、デストラクタ「destructor()」、要素追加「push」、次の要素に進む「next()」、と全要素をプリントする「print()」がある。おおよそ標準的な単方向リストの実装であるが、「push()」と「next()」はメモリ確保の失敗と次の要素が存在しないときにエラー戻り値「-1」を返す。</p>

<div style="text-align: center;"> プログラム11：Tokenのテンプレート </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_Token</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">constant_type</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_Token</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Token</span><span class="p">;</span>

<span class="n">Token</span><span class="o">*</span> <span class="nf">construct</span><span class="p">();</span>
<span class="n">Token</span><span class="o">*</span> <span class="nf">destruct</span><span class="p">(</span><span class="n">Token</span><span class="o">*</span> <span class="n">head</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">push</span><span class="p">(</span><span class="n">Token</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">constant_type</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">next</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span> <span class="n">curent</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">Token</span><span class="o">*</span> <span class="n">head</span><span class="p">);</span>
</code></pre></div></div>

<p>「lex()」関数はプログラム12のように実装する。プログラム10からの入力としてトーケンリスト「this」と文字列「s」が与えられ、whileループを用いて「s」の先頭からトーケンを読み込んでトーケンリストに追加していく。ループする度にまず、余計なスペースやコメントを読み飛ばす。実際の読み込みは三段階「字句参照」「定数参照」「変数参照」に分けて行う。字句参照では、BNFに従って分別したトーケンと比較し、全分別で71行に渡る。定数参照では「0.32341」や「“here”」などの定数を別のファルダ「constant.h」を用いて読み込む。「constant.h」では定数専用のBNFを用いて直接構文解析を行なっているため、5章の構文解析の説明以外のものは省く。最後に、変数参照は字句参照と定数参照に引っ掛からなかったトーケンが変数名として成り立つかどうかを判定する。変数名に許されている小文字、大文字、アンダーバー、から成る塊であれば変数として認識することになる。いずれの段階でも、参照関数は一致すると「1」を返すため、上から最初に一致したものをgoto文を用いて最後の処理に持っていく。最後の処理は抽出したトーケンをトーケンリストに追加することである。</p>

<div style="text-align: center;"> プログラム12：lex()の実装 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">lex</span><span class="p">(</span><span class="n">Token</span><span class="o">*</span> <span class="n">this</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">ps</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">constant_type</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="o">!=</span><span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 余計なスペースを読み飛ばす</span>
        <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="o">==</span><span class="sc">' '</span><span class="p">)</span> <span class="p">{</span><span class="n">s</span><span class="o">++</span><span class="p">;}</span>
        <span class="c1">// 初期化</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">constant_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// コメントを読み飛ばす</span>
        <span class="k">if</span><span class="p">(</span><span class="n">l_compare</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">l_comment</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
        <span class="c1">// 字句参照</span>
        <span class="k">if</span><span class="p">(</span><span class="n">l_compare</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">l_type_specifier</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span> <span class="p">{</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_specifier</span><span class="p">;</span> <span class="k">goto</span> <span class="n">P</span><span class="p">;}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">l_compare</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">l_struct_or_union</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span><span class="n">type</span> <span class="o">=</span> <span class="n">struct_or_union</span><span class="p">;</span> <span class="k">goto</span> <span class="n">P</span><span class="p">;}</span>
<span class="err">　　　　\</span><span class="n">vdots</span>
        <span class="k">if</span><span class="p">(</span><span class="n">l_compare</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">l_exclamation</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span><span class="n">type</span> <span class="o">=</span> <span class="n">exclamation</span><span class="p">;</span> <span class="k">goto</span> <span class="n">P</span><span class="p">;}</span>
        <span class="c1">// 「constant.h」による定数参照</span>
        <span class="k">if</span><span class="p">(</span><span class="n">c_constant</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">constant_type</span><span class="p">))</span> <span class="p">{</span><span class="n">type</span> <span class="o">=</span> <span class="n">constant</span><span class="p">;</span> <span class="k">goto</span> <span class="n">P</span><span class="p">;}</span>
        <span class="c1">// 変数名参照</span>
        <span class="k">if</span><span class="p">(</span><span class="n">l_user_defined</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span><span class="n">type</span> <span class="o">=</span> <span class="n">user_defined</span><span class="p">;</span> <span class="k">goto</span> <span class="n">P</span><span class="p">;}</span>
        <span class="c1">// 字句が参照できなかった</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="c1">// トーケンに要素を追加</span>
    <span class="nl">P:</span>  <span class="n">strncpy</span><span class="p">(</span><span class="n">l_buffer</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">s</span><span class="o">-</span><span class="n">ps</span><span class="p">);</span>
        <span class="n">l_buffer</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="n">ps</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="n">push</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">l_buffer</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">constant_type</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>「l_compare()」の引数として渡している「l_type_specifier」とその後の数字「9」などはそれぞれ型指定子に属するトーケン文字列の配列とその配列の長さを示している。このトーケン文字列の配列の例をプログラム13で示す。
 </p>
<div style="text-align: center;"> プログラム13：トーケン文字列の配列 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">l_type_specifier</span><span class="p">[</span><span class="mi">9</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"void"</span><span class="p">,</span> <span class="s">"char"</span><span class="p">,</span> <span class="s">"short"</span><span class="p">,</span> <span class="s">"int"</span><span class="p">,</span> <span class="s">"long"</span><span class="p">,</span> <span class="s">"float"</span><span class="p">,</span> <span class="s">"double"</span><span class="p">,</span> <span class="s">"signed"</span><span class="p">,</span> <span class="s">"unsigned"</span><span class="p">};</span> <span class="c1">// space</span>
<span class="kt">char</span> <span class="n">l_struct_or_union</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"struct"</span><span class="p">,</span> <span class="s">"union"</span><span class="p">};</span> <span class="c1">// space</span>
<span class="err">\</span> <span class="err">\</span> <span class="err">\</span> <span class="err">\</span> <span class="err">\</span> <span class="err">\</span> <span class="err">\</span><span class="n">vdots</span>
<span class="kt">char</span> <span class="n">l_exclamation</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"!"</span><span class="p">};</span>
</code></pre></div></div>

<p>プログラム14では「l_compare()」の実装を示す。先程説明した文字列「s」、トーケン文字列の配列「hash」、トーケン文字列の配列の長さ「keyCount」を除いて、真偽値の「cmpterm」が与えられている。「cmpterm」が真であれば、型指定子のように変数名の一部でないことを確かめる様になっている。「l_variable_char()」は文字が変数名に使用可能かどうかを返す単純な関数である。また、「l_compare()」で一致があった場合、文字列をその分進めるために、文字列「s」は二重ポインタとして受け取っている。</p>

<div style="text-align: center;"> プログラム14：l_compare()の実装 [2] </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">l_compare</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmpterm</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">hash</span><span class="p">[][</span><span class="mi">10</span><span class="p">],</span> <span class="kt">int</span> <span class="n">keyCount</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">keyCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">strlen</span><span class="p">(</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cmpterm</span> <span class="o">&amp;&amp;</span> <span class="n">strlen</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
                        <span class="n">l_variable_char</span><span class="p">((</span><span class="o">*</span><span class="n">s</span><span class="p">)[</span><span class="n">strlen</span><span class="p">(</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">])]))</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="o">*</span><span class="n">s</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="5構文解析syntax-analysis">5.構文解析（Syntax Analysis）</h1>
<h2 id="51設計">5.1.設計</h2>

<p>構文解析の目的は抽出したトーケンの羅列から構文的な意味を見出すことである。最終的な出力をAST（Abstract Syntax Tree, 抽象構文木）として、その中間過程であるDepthmap（深度マップ）とPT（Parse Tree, 解析木）も求める[1]。構文解析ではBNFの各要素を関数とみなし、再帰呼び出し的に文法参照を分割していく。この際、Depthmapでは文法一致につながらない呼び出しまで出力し、PTでは文法一致につながる呼び出しだけを出力し、ASTではPTを更に抽象化して必要最小限の情報量に直したものを出力する。</p>

<p>BNFを直接関数に変換する際には、左再帰を書き換えることが重要になる。BNFの豊富な種類と表現基準の問題点として、処理の統一が挙げられる。BNFにおける左再帰とは、処理の最も左側に再帰呼び出しが置かれた要素のことを意味する。プログラム15で示す「additive-expression」は左再帰の一例であり、そのまま関数にすると「multiplicative-expression」として解釈されない限り、2行目の「additive-expression」によって無限呼び出しが発生することがわかる。</p>

<div style="text-align: center;"> プログラム15：BNFの左再帰の例[2] </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;additive-expression&gt; ::= &lt;multiplicative-expression&gt;
                        | &lt;additive-expression&gt; + &lt;multiplicative-expression&gt;
                        | &lt;additive-expression&gt; - &lt;multiplicative-expression&gt;
</code></pre></div></div>

<p>プログラム15を左再帰でないように書き換える一つの方法として、プログラム16の様に「additive-expression-suffix」などのsuffix（接尾辞）要素を新たに定義し、元の定義を分割することができる。変更前のプログラム15を読み解くと、一個以上の「multiplicative-expression」が「+」や「-」で繋がっていることを表している。また、変更後のプログラム16を読み解くと、一個以上の「multiplicative-expression」の後に任意個の「+」や「-」の接頭辞をもつ「multiplicative-expression」が繋がっていることを表している。結果、同じことを意味していることになる。簡潔化のため、本プロジェクトでは左再帰のBNF要素を全てこの様に接尾辞要素を追加して書き換えている。</p>

<p>なお、プログラム16における「+」「-」はBNFの非終端要素で使われているトーケンであるため、独自の列挙型整数が割り振られている。例えば、「additive-expression-suffix」の1行目を関数に変換したければ、現在のトーケンを「1 (plus)」と照らし合わせ、一致すれば次に「multiplicative-expression」の関数に移行する。</p>

<div style="text-align: center;"> プログラム16：BNFの左再帰を接尾辞を用いて書き換えたもの </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;additive-expression&gt; ::= &lt;multiplicative-expression&gt; {&lt;additive-expression-suffix&gt;}*

&lt;additive-expression-suffix&gt; ::=  + &lt;multiplicative-expression&gt;
                                    |  - &lt;multiplicative-expression&gt;
</code></pre></div></div>

<p>次に、構文解析のおおよその流れを先に例として扱った「int x = 3;」を用いて説明する。プログラム17のBNFでは真っ先に処理される4つの要素を示している。このBNFを読み解くと、C言語のプログラムは一つの「Translation Unit」であり、それは任意個の「External Declaration」から成る。「External Declaration」は「Function Definition」（関数定義）か「Declaration」（宣言）のいずれかである。</p>

<div style="text-align: center;"> プログラム17：bnfの最初の4要素[2] </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;translation-unit&gt; ::= {&lt;external-declaration&gt;}*

&lt;external-declaration&gt; ::= &lt;function-definition&gt;
                              | &lt;declaration&gt;

&lt;function-definition&gt; ::= {&lt;declaration-specifier&gt;}* &lt;declarator&gt; {&lt;declaration&gt;}* &lt;compound-statement&gt;

&lt;declaration&gt; ::=  {&lt;declaration-specifier&gt;}+ {&lt;init-declarator-list&gt;}* ;
</code></pre></div></div>

<p>プログラム17の4要素に着目して、参照処理を追っていくと図3の様になる。「Translation Unit」,「External Declaration」と始まり、「Function Definition」と「Declaration」に分裂する様子がまず見受けられる。
 
最初の「Function Definition」という枝では、任意個許される「Declaration Specifier」を一個拾い、一個必須の「Declarator」を拾い、任意個許される「Declaration」を一個も拾わず、一個必須の「Compound Statement」を拾うことができない。つまり、「int x = 3;」は「Function Definition」（関数定義）ではないことになり、この枝は一致に至らない。</p>

<p>次の「Declaration」という枝では、任意個許される「Declaration Specifier」を一個拾い、「Init Declarator List」の中で一個の「Init Declarator」を拾い、最後にセミコーロンを一個拾う。つまり、「int x = 3;」は「Declaration」（宣言）であることになり、この枝は一致に至ったため、一つ目の「External Declaration」として処理される。</p>

<p>最後に、「External Declaration」は任意個許されるが二つ目は見つからず、構文解析は終了する。</p>

<p><img src="/assets/2025-5-28-C89-Parser/figure3.svg" alt="figure3" title="figure3" class="img-large-centered" /></p>
<div style="text-align: center;"> 図3：BNFの最初の4要素に着目して参照処理を追った結果 </div>
<p><br /></p>

<p>図3で示す全ての呼び出しを出力したものを Depthmapとする。また、PTは図3を「translation unit」から緑の枝のみを多分木としてまとめたものとして理解できる。</p>

<p>ここでは、PTをASTに変換する処理は3段階「終端圧縮」「接尾辞圧縮」「中間圧縮」に分けて実行する。</p>

<p>終端圧縮では、ある要素の唯一の枝が終端要素であれば、その要素に終端要素を折りたたむ。終端要素は単独ではただのトーケンであるが、その上の要素によって意味づけられるため中間過程を圧縮することを考える。プログラム18で示すのは「int x, y;」のPTとそれに終端圧縮を施したものである。終端要素を表す「symbol」が単独で上の要素から生えている部分に注目すると、「symbol」についていた終端トーケンがそのまま上の要素に移行していることがわかる。また、最初の「type specifier」の部分の過程を図4で示す。</p>

<div style="text-align: center;"> プログラム18： PTを終端圧縮する前（上）と後（下） </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
translation unit
└── external declaration
    └── declaration
        ├── declaration specifier
        │   └── type specifier
        │       └── symbol {int}
        ├── init declarator list
        │   ├── init declarator
        │   │   └── declarator
        │   │       └── direct declarator
        │   │           └── identifier
        │   │               └── symbol {x}
        │   └── init declarator list suffix
        │       ├── symbol {,}
        │       └── init declarator
        │           └── declarator
        │               └── direct declarator
        │                   └── identifier
        │                       └── symbol {y}
        └── symbol {;}	

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
translation unit
└── external declaration
    └── declaration
        ├── declaration specifier
        │   └── type specifier {int}
        ├── init declarator list
        │   ├── init declarator
        │   │   └── declarator
        │   │       └── direct declarator
        │   │           └── identifier {x}
        │   └── init declarator list suffix
        │       ├── symbol {,}
        │       └── init declarator
        │           └── declarator
        │               └── direct declarator
        │                   └── identifier {y}
        └── symbol {;}

</code></pre></div></div>

<p><img src="/assets/2025-5-28-C89-Parser/figure4.svg" alt="figure4" title="figure4" class="img-large-centered" /></p>
<div style="text-align: center;"> 図4：終端圧縮の一例 </div>
<p><br /></p>

<p>接尾辞圧縮では、左再帰を書き換えるために追加した接尾辞要素を取り除く。プログラム19で示すのは終端圧縮済みのPTとそれに接尾辞圧縮を施したものである。この際に圧縮した「init declarator list」と「init declarator list suffix」は「int x, y;」における「x, y」の部分を表し、「init declarator」「symbol（comma）」「init declarator」から成る。つまり、「init declarator list suffix」の中身を「init declarator list」と並ぶように一段分上に上げればいい。また、この様子を図5で示す。</p>

<div style="text-align: center;"> プログラム19： PTを接尾辞圧縮する前（上）と後（下） </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
translation unit
└── external declaration
    └── declaration
        ├── declaration specifier
        │   └── type specifier {int}
        ├── init declarator list
        │   ├── init declarator
        │   │   └── declarator
        │   │       └── direct declarator
        │   │           └── identifier {x}
        │   └── init declarator list suffix
        │       ├── symbol {,}
        │       └── init declarator
        │           └── declarator
        │               └── direct declarator
        │                   └── identifier {y}
        └── symbol {;}

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
translation unit
└── external declaration
    └── declaration
        ├── declaration specifier
        │   └── type specifier {int}
        ├── init declarator list
        │   ├── init declarator
        │   │   └── declarator
        │   │       └── direct declarator
        │   │           └── identifier {x}
        │   ├── symbol {,}
        │   └── init declarator
        │       └── declarator
        │           └── direct declarator
        │               └── identifier {y}
        └── symbol {;}

</code></pre></div></div>

<p><img src="/assets/2025-5-28-C89-Parser/figure5.svg" alt="figure5" title="figure5" class="img-large-centered" /></p>
<div style="text-align: center;"> 図5：接尾辞圧縮の一例 </div>
<p><br /></p>

<p>中間圧縮では、一本の枝しか持たない要素を省略する。一本の枝しか持たない要素は言うならば、構文参照の中間過程でしかない。一本の枝で繋がれた長い要素の連鎖を想像すると、唯一トーケンの直接的な意味を表す新しい終端要素だけを保存しながら、中間の要素を消していくイメージである。プログラム20で示すのは終端圧縮および接尾辞圧縮済みのPTとそれに中間圧縮を施したものである。図6で示すように、「external declaration」は「declaration」の枝を一本のみ持つため、省略されている。その他に「init declarator list」の中身は一本の枝で繋がれた連鎖の様なものであるため、全て省力して新しく終端要素となった「identifier」と「symbol(comma)」が引き上げられている。</p>

<div style="text-align: center;"> プログラム20： PTを中間圧縮する前（上）と後（下） </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
translation unit
└── external declaration
    └── declaration
        ├── declaration specifier
        │   └── type specifier {int}
        ├── init declarator list
        │   ├── init declarator
        │   │   └── declarator
        │   │       └── direct declarator
        │   │           └── identifier {x}
        │   ├── symbol {,}
        │   └── init declarator
        │       └── declarator
        │           └── direct declarator
        │               └── identifier {y}
        └── symbol {;}

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
translation unit
└──  declaration
        ├── type specifier {int}
        ├── init declarator list
        │   ├── identifier {x}
        │   ├── symbol {,}
        │   └── identifier {y}
        └── symbol {;}

</code></pre></div></div>

<p><img src="/assets/2025-5-28-C89-Parser/figure6.svg" alt="figure6" title="figure6" class="img-large-centered" /></p>
<div style="text-align: center;"> 図6：中間圧縮の1例 </div>
<p><br /></p>

<h2 id="52実装">5.2.実装</h2>

<p>プログラム21では構文解析に理想的なmainの形を示している。字句解析の様に、行ごとの構文確認は数倍難しくなるため、単純に抽出したトーケンリストに一回呼び出す。正常に構文解析が終了すれば「compiled successfully」、失敗したら「syntax error」と標準出力する。</p>

<div style="text-align: center;"> プログラム21：構文解析に理想的なmainの形 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// open file</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"invalid arguments</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;}</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"unable to open file</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span> 
    <span class="c1">// construct tokens and objects</span>
    <span class="n">Token</span><span class="o">*</span> <span class="n">tokens</span>  <span class="o">=</span> <span class="n">construct</span><span class="p">();</span>
    <span class="err">\</span><span class="n">vdots</span>
    <span class="c1">// syntactical analysis  </span>
    <span class="k">if</span><span class="p">(</span><span class="n">syn</span><span class="p">(</span><span class="n">tokens</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"syntax error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="k">goto</span> <span class="n">E</span><span class="p">;}</span>
    <span class="c1">// no errors</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"compiled successfully</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="nl">E:</span>  <span class="c1">// close file</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>プログラム22で示す構文解析関数「syn()」の定義は、「s_translation_unit()」の呼び出しで構文解析が始まり、最後の条件文内で出来上がったPTをASTに変換する。</p>

<div style="text-align: center;"> プログラム22：syn()関数の定義 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">syn</span><span class="p">(</span><span class="n">Token</span><span class="o">*</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//  Depthmapを開く</span>
    <span class="n">s_syntax_depth_map</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"./Meta/depthmap.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">s_syntax_depth_map</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"depthmap failed to open</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 構文解析</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">s_F_end_of_token</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">s_translation_unit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// Depthmapを閉じる</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">s_syntax_depth_map</span><span class="p">);</span>
    <span class="c1">// PT出力、AST作成、AST出力</span>
    <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n_print</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="s">"./Meta/pt.txt"</span><span class="p">);</span>
        <span class="n">n_simplify</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="n">n_print</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="s">"./Meta/ast.txt"</span><span class="p">);</span>
        <span class="n">n_free</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>BNFを関数に変換する際には、プログラム23とプログラム24の様に行う。プログラム24の関数自体は、現在処理中のトーケンへのポインタとDepthmap用の整数「depth」を受け取り、部分木へのポインタを返す。プログラム23のBNFは「direct declarator」の２通りの可能性を示しているため、まずこの節目で処理を分割する。gotoラベルに着目して「c2」の手前と「f」の手前とで関数を分けることができる。「identifier」のようなBNFの単独要素は、プログラム24の最初のif文のように訳すことができる。「s_identifier()」の呼び出しが一致する場合、何もせず次の行に進む。逆に、「s_identifier()」の結果が一致しない場合、次のラベル「c2」に順次移行する。</p>

<div style="text-align: center;"> プログラム23：direct declarator のBNF [2] </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;direct-declarator&gt; ::= &lt;identifier&gt; {&lt;direct-declarator-suffix&gt;}*
                          | ( &lt;declarator&gt; ) {&lt;direct-declarator-suffix&gt;}*
</code></pre></div></div>

<div style="text-align: center;"> プログラム24：direct declaratorの関数 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">s_direct_declarator</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span> <span class="n">token</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINTMAP</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="s">"direct declarator"</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">token</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">)</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">n_construct</span><span class="p">(</span><span class="n">n_direct_declarator</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">Token</span><span class="o">*</span> <span class="n">ptoken</span> <span class="o">=</span> <span class="o">*</span><span class="n">token</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">n_push</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">s_identifier</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span> <span class="k">goto</span> <span class="n">c2</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">n_push</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">s_direct_declarator_suffix</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)));</span>
    <span class="k">goto</span> <span class="n">t</span><span class="p">;</span>
<span class="nl">c2:</span> <span class="o">*</span><span class="n">token</span> <span class="o">=</span> <span class="n">ptoken</span><span class="p">;</span> <span class="n">n_reset</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">n_push</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">s_compare</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">h_parenthesis</span><span class="p">)))</span> <span class="k">goto</span> <span class="n">f</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">n_push</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">s_declarator</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span> <span class="k">goto</span> <span class="n">f</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">n_push</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">s_compare</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">t_parenthesis</span><span class="p">)))</span> <span class="k">goto</span> <span class="n">f</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">n_push</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">s_direct_declarator_suffix</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)));</span>
    <span class="k">goto</span> <span class="n">t</span><span class="p">;</span>
<span class="n">f</span> <span class="o">:</span> <span class="o">*</span><span class="n">token</span> <span class="o">=</span> <span class="n">ptoken</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">n_free</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="n">t</span> <span class="o">:</span> <span class="k">return</span> <span class="n">node</span><span class="p">;</span>        
<span class="p">}</span>
</code></pre></div></div>

<p>プログラム23の「direct declarator suffix」のようなBNFの任意個許される要素は、プログラム24のwhile文のように訳すことができる。「s_direct_declarator_suffix」が一致する限り読み込んでいくことを意味し、一つも一致しない場合にも許されるため次のラベルに飛ぶ必要もない。プログラム24の場合では、いずれの場合でも一致が確定しているため、次の「goto t;」で現在の部分木を返す。BNFの「declarator」の周りの括弧はトーケンの列挙型を確認すれば確かめられ、プログラム24で示すように関数「s_compare()」を用いて同じように一致を確認をしている。</p>

<p>プログラム24の先頭部分にある「PRINTMAP」は、Depthmapのために、全ての関数の先頭で実行されるマクロである。続く2行では、この関数以下の木構造を表す部分木を宣言し、処理前のトーケンリストにおける位置を一時的に保存している。また、構文参照呼び出しを囲んでいる「n_push」は、中の呼び出しの戻り値が部分木であれば「node」に追加して1を返し、NULLであれば0を返す。「t」を除く各ラベルの後に「*token = ptoken;」と「n_reset(node);」があるのは、各部分で一致しなかった場合に進められた「token」と追加された「node」を初期状態に戻している。つまり、トーケンリストの位置は必ず進められるし、部分木は必ず生成されるが、一致した場合のみにトーケンリスト位置の変更が反映され、部分木が上のレベルに返される。</p>

<p>最後に木構造のテンプレートをプログラム25で示す。ここで言う「type」は以前扱ってきた「type」と異なり、別の列挙型で構文解析における関数やBNF要素の対応を示す。</p>

<div style="text-align: center;"> プログラム25：Nodeのテンプレート </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">NODE</span><span class="p">{</span>
   <span class="k">struct</span> <span class="n">NODE</span><span class="o">**</span> <span class="n">next</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
   <span class="k">const</span> <span class="n">Token</span><span class="o">*</span> <span class="n">token</span><span class="p">;</span> <span class="c1">// allocated and freed by token</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>

<span class="n">Node</span><span class="o">*</span> <span class="nf">n_free</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">);</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">n_reset</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">);</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">n_construct</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="n">Token</span><span class="o">*</span> <span class="n">token</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">n_push</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">this</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">n_print</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">this</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">n_helper</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">this</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">endge</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">[]);</span>
<span class="kt">void</span> <span class="nf">n_simplify</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">this</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">n_compress_symbol</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">this</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">n_compress_chain</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">this</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">n_compress_suffix</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">this</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">n_get</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
</code></pre></div></div>

<p>「n_free()」と「n_reset()」はいずれも木構造を解放しているが、後者の場合では枝を全てもぎ取って根を残した様なものである。「n_construct()」「n_push()」「n_print()」「n_helper()」はそれぞれコンストラクタ、枝追加、出力、出力用の再帰関数、となっているが、これらは比較的標準的な実装となっている。次に、全ての圧縮操作を呼び出す「n_simplify()」の実装をプログラム26で示す。</p>

<div style="text-align: center;"> プログラム26：n_simplify()の実装  </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">n_simplify</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">this</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">n_compress_symbol</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
    <span class="n">n_compress_suffix</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
    <span class="n">n_compress_chain</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">n_simplify</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>プログラム26でわかるように、終端圧縮、接尾辞圧縮、中間圧縮をそれぞれ一回ずつ呼び出し、全ての枝について再帰を呼び出す。圧縮関数は条件が成立しないと圧縮が施されないため、このように深度別に実行すると考えやすくなる。比較的わかりにくい「n_compress_suffix」（接尾辞圧縮）の実装をプログラム27で解説する。</p>

<div style="text-align: center;"> プログラム27：n_compress_suffix()の実装  </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">n_compress_suffix</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">this</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">n_struct_declarator_list</span><span class="p">:</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">n_direct_declarator</span><span class="p">:</span> <span class="k">break</span><span class="p">;</span>
        <span class="err">\</span><span class="n">vdots</span>
        <span class="k">case</span> <span class="n">n_initializer_list</span><span class="p">:</span> <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// no suffix to compress</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">Node</span><span class="o">**</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">));</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">];</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="n">i</span><span class="p">)</span> <span class="n">k</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">free</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>接尾辞圧縮はそもそも接尾辞要素を追加したBNF要素のみに施せるから、プログラム27の先頭部分にあるswitch文を用いて現在のnodeが圧縮対象かどうか確認する。圧縮対象のnodeについて「next」を接尾辞の中身分足したサイズで再確保する。再確保した「next」に今までの要素をコピーしたのち、接尾辞要素の中身もコピーしていく。最後に、抜かれた接尾辞nodeは解放する。
 </p>
<h1 id="6制限事項">6.制限事項</h1>

<p>実際に使われているC言語のコンパイラは本プロジェクトとレポートの範囲をはるかに超える規模と複雑さを有している。本章では、今回実装したパーサーが標準的なC言語のコンパイラと異なる点について補足する。簡単なものから始めると、複数行を跨ぐコメント、すなわち「/<em>」「</em>/」で指定されるコメントは扱えない。―行コメント「//」より実装がやや複雑で、コンパイラの仕組みを解明する趣旨にさほど関係ないため実装は省いた。</p>

<p>次に、実際のCファイルには含まれ得るが、パーサーの範囲外であるため処理していないものがある。例えば、プリプロセッサディレクティブ、マクロ宣言、ファイルインクルードなどが挙げられる。プリプロセッサディレクティブやマクロ宣言については、Cスタンダード[3]などに記載されるBNFを用いて本レポートの実装手法と同様に構文解析し、単純なトーケン置換で実現することができる。</p>

<p>最後に、実際のCコンパイラに含まれ、パーサーの範囲内であるが、実装が煩雑であるため省いたものについて補足する。今回実装したパーサーにはidentifierと呼ばれる変数や関数名のスコープ確認や、式及び代入のタイプ確認の機能は含まれていない。実際のCコードでは、identifierなる変数や関数名は、それぞれタイプとスコープを持っている。タイプはその通り、変数のタイプや関数の戻り値を意味する。スコープは主に変数の宣言時からメモリの解放時までの期間、いわゆる「ライフタイム」を指し示している。簡単な例として、変数や関数が、宣言される前に使われていないことを確かめる作業がある。高度な例として、compound statement と称される鉤括弧「{}」内で宣言された変数が、その括弧外（スコープ外）で使われていないことを確かめる作業がある。これらの確認を行うのは一見容易に思えるが、ユーザー定義型のstructやunion、もしくはtypedefによる型宣言を考慮し始めると、構文解析と意味解析を隔てるものが薄れて消えてしまう。実際のコンパイラでは構文解析を複数回行ったり、抽象構文木を並行に作りながらの構文解析を行うといった対処法がある。一方、式及び代入のタイプ確認では、ある式のタイプをその構成要素から推測し、代入文や引数などのタイプ不一致を知らせる。Identifierの例のように、これも一見容易に見えるがユーザ定義型などを考慮すると煩雑になる上、intはintというー対ーの対応になるとは限らないことが難しさを際立たせている。例えば、int型の変数に代入できるものとしてint型、char型、float型、double型、ポインタ、のようにいくらでも互換や変換が可能である。このような対応はCスタンダード[3]にも記載されていないため、全てのケースについて網羅することは極めて難しいため、今回のパーサーには実装していない。
 </p>
<h1 id="7実験">7.実験</h1>

<p>本章では、いくつかの代表的なC言語の要素を実際にコンパイルし、コンパイルが通るものについてはそのASTを考察し、コンパイルの通らないものについてはその理由を補足する。プログラム28で示す最初の実験では、main関数の宣言のみをコンパイルした。実際のCコンパイラはmainが定義されていないためエラーを挙げるが、本パーサーはそのようなメタ読みは行わず、他の関数同様の関数宣言とみなしている。</p>

<div style="text-align: center;"> プログラム28：関数宣言  </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">();</span>	
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
translation unit
└── declaration
    ├── type specifier {int}
    ├── direct declarator
    │   ├── identifier {main}
    │   ├── symbol {(}
    │   └── symbol {)}
    └── symbol {;}

</code></pre></div></div>

<p>プログラム29の二つ目の実験では、通常終了するシンプルなmain関数をコンパイルしてみる。右の抽象構文木からわかるように、プログラム28ではdeclarationだった枠組みが今回はfunction definitionになっている。これはプログラム30のBNFにあるように、関数宣言と定義は全く別ものとして解釈されていることを示している。プログラム29の場合は関数定義であるため、type specifierが型を拾い、direct declaratorが関数名と引数リストを拾い、compound statementとして鉤括弧の中身が解釈されている。なお、コメントは飛ばされ、return文はjump statementとして整数constantの0を返すことになる。</p>

<div style="text-align: center;"> プログラム29：通常終了するmain </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// some code</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>	
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
translation unit
└── function definition
    ├── type specifier {int}
    ├── direct declarator
    │   ├── identifier {main}
    │   ├── symbol {(}
    │   └── symbol {)}
    └── compound statement
        ├── symbol {{}
        ├── jump statement
        │   ├── symbol {return}
        │   ├── constant {0}
        │   └── symbol {;}
        └── symbol {}}

</code></pre></div></div>

<div style="text-align: center;"> プログラム30：declarationとfunction definitionの違い </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&lt;external-declaration&gt; ::= &lt;function-definition&gt;
                         | &lt;declaration&gt;

&lt;function-definition&gt; ::= {&lt;declaration-specifier&gt;}* &lt;declarator&gt; {&lt;declaration&gt;}* &lt;compound-statement&gt;

&lt;declaration&gt; ::=  {&lt;declaration-specifier&gt;}+ {&lt;init-declarator-list&gt;}* ;

</code></pre></div></div>

<p>プログラム31で示す三つ目の実験では、さまざまな変数定義をコンパイルしている。最初の1行ではinit declarator listを用いてidentifier「x」とinit declarator「y=10」を同じ行で定義している。2行目では、double型の変数「f」を定数 $1.54334 \times 10^{-34}$ で初期化している。この定数は先に触れた「constant.h」の定数BNFに基づいて構文解析が施され、最終的にconstant字句として解釈される。同様に、3行目の文字列を初期化するために文字列リテラルとして「constant.h」で解釈される。また、抽象構文木については、「s[10]」はdirect declaratorとして一括で拾われている。4行目では整数配列を初期化している。初期化に用いている「{1, 2, 3}」はinitializer listを含むinitializerとして解釈されている。</p>

<div style="text-align: center;"> プログラム31：変数定義  </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">1.54334E-34</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">"something"</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>	
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
translation unit
├── declaration
│   ├── type specifier {int}
│   ├── init declarator list
│   │   ├── identifier {x}
│   │   ├── symbol {,}
│   │   └── init declarator
│   │       ├── identifier {y}
│   │       ├── symbol {=}
│   │       └── constant {10}
│   └── symbol {;}
├── declaration
│   ├── type specifier {double}
│   ├── init declarator
│   │   ├── identifier {f}
│   │   ├── symbol {=}
│   │   └── constant {1.54334E-34}
│   └── symbol {;}
├── declaration
│   ├── type specifier {char}
│   ├── init declarator
│   │   ├── direct declarator
│   │   │   ├── identifier {s}
│   │   │   ├── symbol {[}
│   │   │   ├── constant {10}
│   │   │   └── symbol {]}
│   │   ├── symbol {=}
│   │   └── constant {"something"}
│   └── symbol {;}
└── declaration
    ├── type specifier {int}
    ├── init declarator
    │   ├── direct declarator
    │   │   ├── identifier {array}
    │   │   ├── symbol {[}
    │   │   ├── constant {3}
    │   │   └── symbol {]}
    │   ├── symbol {=}
    │   └── initializer
    │       ├── symbol {{}
    │       ├── initializer list
    │       │   ├── constant {1}
    │       │   ├── symbol {,}
    │       │   ├── constant {2}
    │       │   ├── symbol {,}
    │       │   └── constant {3}
    │       └── symbol {}}
    └── symbol {;}

</code></pre></div></div>

<p>プログラム32で示す4つ目の実験では、条件文をコンパイルしている。関数外での宣言や定義以外の処理を置くことはエラーになるため、単純なmain関数の中から切り取ったものである。If-else文の枠組みはif文やswitch文同様のselection statementであり、else ifの部分はif-else文の中のif文として解釈されていることがわかる。また、条件「1 » 1」も正しくshift expressionとして認識され、return文は鉤括弧なしでもきちんと認識されている。</p>

<div style="text-align: center;"> プログラム32：条件文 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// some code</span>
<span class="p">}</span>	   
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    └── compound statement
        ├── symbol {{}
        ├── selection statement
        │   ├── symbol {if}
        │   ├── symbol {(}
        │   ├── shift expression
        │   │   ├── constant {1}
        │   │   ├── symbol {&gt;&gt;}
        │   │   └── constant {1}
        │   ├── symbol {)}
        │   ├── jump statement
        │   │   ├── symbol {return}
        │   │   ├── constant {0}
        │   │   └── symbol {;}
        │   ├── symbol {else}
        │   └── selection statement
        │       ├── symbol {if}
        │       ├── symbol {(}
        │       ├── constant {1}
        │       ├── symbol {)}
        │       └── compound statement
        │           ├── symbol {{}
        │           └── symbol {}}

</code></pre></div></div>

<p>プログラム33で示す5つ目の実験では、forループをコンパイルしている。これもまた単純なmainの中身を切り取ったものである。Whileループ同様のiteration statementの枠組みの中でassignment expression, relational expression, postfix expressionの分別はいずれも正しく行われている様子が伺える。</p>

<div style="text-align: center;"> プログラム33：繰り返し文 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// some code</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
	├── iteration statement
        │   ├── symbol {for}
        │   ├── symbol {(}
        │   ├── assignment expression
        │   │   ├── identifier {i}
        │   │   ├── assignment operator {=}
        │   │   └── constant {0}
        │   ├── symbol {;}
        │   ├── relational expression
        │   │   ├── identifier {i}
        │   │   ├── symbol {&lt;}
        │   │   └── constant {5}
        │   ├── symbol {;}
        │   ├── postfix expression
        │   │   ├── identifier {i}
        │   │   └── symbol {++}
        │   ├── symbol {)}
        │   └── compound statement
        │       ├── symbol {{}
        │       └── symbol {}}

</code></pre></div></div>

<p>プログラム34で示す6つ目の実験では、switch文をコンパイルしている。Switch文は正しくselection statement として認識され、identifier「x」についてlabeled statement「case 0:」と「case 1:」に分けられている。また、break文は正しくjump statementとして認識されていることも確認できる。</p>

<div style="text-align: center;"> プログラム34：switch文 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">switch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  
	├── selection statement
        │   ├── symbol {switch}
        │   ├── symbol {(}
        │   ├── identifier {x}
        │   ├── symbol {)}
        │   └── compound statement
        │       ├── symbol {{}
        │       ├── labeled statement
        │       │   ├── symbol {case}
        │       │   ├── constant {0}
        │       │   ├── symbol {:}
        │       │   └── jump statement
        │       │       ├── symbol {break}
        │       │       └── symbol {;}
        │       ├── labeled statement
        │       │   ├── symbol {case}
        │       │   ├── constant {1}
        │       │   ├── symbol {:}
        │       │   └── jump statement
        │       │       ├── symbol {break}
        │       │       └── symbol {;}
        │       └── symbol {}}

</code></pre></div></div>

<p>プログラム35で示す7つ目の実験では、宣言されていない変数を使うコードをコンパイルしてみた。このコードは実際のコンパイラを通ることはないが、本パーサーは文脈なしにただの代入文のように解釈する。スコープ確認がついていたら、「Allowed」のスコープ外の使用といった形でシンタックスエラーになる。</p>

<div style="text-align: center;"> プログラム35：宣言されてない変数を使う  </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Allowed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
	├── expression statement
        │   ├── assignment expression
        │   │   ├── identifier {Allowed}
        │   │   ├── assignment operator {=}
        │   │   └── constant {1}
        │   └── symbol {;}

</code></pre></div></div>

<p>以下ではコンパイルが失敗したコードをいくつか紹介する。一つ目はプログラム36で示すような不正変数名である。C89では変数名にはアルファベット小文字、大文字、「＿」のみが許されているため、「unallowed123」は不正変数名になる。実際に字句解析の結果を調べると、user-defined「unallowed」とinteger constant「123」に分けられているため、構文解析ではシンタックスエラーとなる。</p>

<div style="text-align: center;"> プログラム36：不正変数名 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">unallowed123</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>プログラム37は先ほど説明した、関数外の処理を示している。Main関数のcompound statementの外で条件文の処理が行われているため、これはシンタックスエラーになる。</p>

<div style="text-align: center;"> プログラム37：関数外の処理 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>

<p>プログラム38では単純な変数定義にセミコロンが欠落している例を示している。この例を含む多くの場合には、シンタックスエラーとなるが、二つの行が合体して正しい構文をなす際にはエラーなくコンパイルされる。これは現実のコンパイラと変わらない。</p>

<div style="text-align: center;"> プログラム38：セミコロンの欠落 </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>プログラム39ではfor文のインデックス変数「i」がfor文内で宣言されているものを示している。これはC99以降では可能となったが、C89では許されていないためシンタックスエラーを挙げる。実際にC89のBNFを見ると、プログラム40で示すようにcompound statementの定義、すなわち関数の内部処理は任意個の宣言の後に、任意個の処理が想定されている。</p>

<div style="text-align: center;"> プログラム39：宣言が処理の先に来ない場合  </div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div style="text-align: center;"> プログラム40：compound statement のBNF </div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&lt;compound-statement&gt; ::= { {&lt;declaration&gt;}* {&lt;statement&gt;}* }

</code></pre></div></div>

<h1 id="8おわりに">8.おわりに</h1>
<p>本レポートでは、C言語のコンパイラの仕組みを学習し、解析部分の一部を設計及び実装した。今回実装したパーサーは字句解析と構文解析から成り、入力コードから抽象構文木を生成するところまで実装した。また、この過程に必要となるBNFや構文木についても学びを深めた。最後に、実装したパーサーにテストコードを入力し、その出力について考察した。</p>

<p>このプロジェクトを進める中で、特にBNFの使い方がとても印象的であった。BNFの項をそのまま関数とし、文法を共有する他に、その解析法まで共有できるのは感動的なものである。一方で、コンパイラの内部を学習していく中で、その規模に萎縮してしまう部分もあった。今後プログラミングと深く関わっていく者として、今回の経験と学びを大切にしていきたいと感じる。</p>

<h1 id="9参考文献">9.参考文献</h1>

<p>[1]. “コンパイラ/コンパイラの概説 - Wikibooks,” Wikibooks.org, 2022. https://ja.wikibooks.org/wiki/%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9/%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E6%A6%82%E8%AA%AC (accessed Dec. 30, 2024).</p>

<p>[2]. “The syntax of C in Backus-Naur form,” Wmich.edu, 2021. https://cs.wmich.edu/~gupta/teaching/cs4850/sumII06/The%20syntax%20of%20C%20in%20Backus-Naur%20form.htm</p>

<p>[3]. “1999 C Standard Committee Draft,” open-std.org, Sep. 07, 2007. https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf (accessed Feb. 03, 2025).</p>]]></content><author><name>武藤皐蘭</name></author><category term="projects" /><summary type="html"><![CDATA[プログラムに携わるエンジニアとしてコンパイラは当然のように使う道具である。ただし、その裏には人間の意思を機械が実行できる指示に変換するための奥深い技術がある。また、コンパイラを勉強することによって、コンパイルエラーの処理能力が強化されたり、その言語の理解度が深まるといった利点が挙げられる。当然のように使う道具への感謝意識を持つことも技術者として大切なように思える。]]></summary></entry><entry><title type="html">差動駆動およびホロノミックロボット向け経路計画インターフェース</title><link href="http://localhost:4000/projects/Path-Planner/" rel="alternate" type="text/html" title="差動駆動およびホロノミックロボット向け経路計画インターフェース" /><published>2025-05-28T00:00:00+09:00</published><updated>2025-05-28T00:00:00+09:00</updated><id>http://localhost:4000/projects/Path-Planner</id><content type="html" xml:base="http://localhost:4000/projects/Path-Planner/"><![CDATA[<p>このプロジェクトでは、差動駆動およびホロノミック <a href="https://www.vexrobotics.com/">Vex</a> ロボットの滑らかな経路生成における <a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline">Cubic Hermite Spline</a> の応用について詳述します。経路生成は <a href="https://www.desmos.com/">Desmos</a> の使用により簡略化されています。また、本プロジェクトでは、初速度と最終速度、初期加速度と最終加速度、移動距離を与えたときの速度プロファイルを生成する簡単な方法も提案しています。これは高校最終学年の間に取り組んだプロジェクトであり、多くの改善の余地が残されていますが、その一部を本記事で紹介します。</p>

<h1 id="リンク">リンク</h1>

<p><a href="https://github.com/Meilan39/Vex-Library-Public">GitHubリポジトリ</a><br />
<a href="https://drive.google.com/file/d/1s2wVjT6lOR31UDFTtDkMZKHKzBM_V8rS/view">プレゼンテーション</a></p>

<p>開始点・終了点および速度を可視化できる通常のPath Plannerバージョン。</p>

<p><a href="https://www.desmos.com/calculator/zqpztqvvoi">Path Planner</a></p>

<p>開始点・中間点・終了点および速度を可視化できるPath Planner Plusバージョン。Path Planner Plusは、長いまたは複雑な経路で追加の中間点が必要な場合に最適です。</p>

<p><a href="https://www.desmos.com/calculator/dg7kybaxyb">Path Planner Plus</a></p>

<h1 id="使用ツール">使用ツール</h1>

<ul>
  <li>C++</li>
  <li>Desmos</li>
</ul>

<h1 id="動機">動機</h1>

<p>VEX Robotics Competitionでは、「自律制御期間」と呼ばれる時間帯があり、ロボットは事前にプログラムされたルーチンを実行して得点します。多くのチームは、エンコーダ距離や時間ベースのアプローチを用いて、個別の直線経路を連続で実行しています。しかし、この方法では、目的地と現在地の間に障害物がある場合、複数の経路を順に実行する必要があり、非効率で大きな誤差が生じる可能性があります。このプロジェクトの動機は、2点間の連続的かつ柔軟な経路を簡単に生成できるインターフェースを作成することでした。</p>

<h1 id="背景">背景</h1>

<h3 id="三次エルミート補間">三次エルミート補間</h3>

<p>基本的なアイデアは、開始点と終了点、およびそれぞれに対応する「速度」ペアを使用して柔軟な経路を生成することです。開始点と終了点は経路の端点を定義し、「速度」はそれらの向きが経路の曲率に与える影響を示します。「速度」はロボットの実際の速度を意味するのではなく、端点の向きが経路形状に与える「重み」として扱われます。この問題は補間問題であり、ここではエルミートスプライン補間を用いています。エルミートスプラインは、数学的にはよく知られるベジエ曲線と同等とみなすことができますが、開始点と終了点の向きを明示的に定義できる点で、ロボット経路計画においてより適しています。一方、ベジエ曲線では、中間点が物理的意味を持たずに曲率を定義します。</p>

<p>上述のように、エルミートスプラインは以下の4つの情報から生成されます：</p>

<p>$P_0$ ::= 開始点の x-y 座標<br />
$P_1$ ::= 終了点の x-y 座標<br />
$P_2$ ::= 開始点の「速度」<br />
$P_3$ ::= 終了点の「速度」</p>

<p>次に、パラメータ $t \in \mathbf{R}$ に関する一般的な三次多項式とその導関数を考えます。係数 $a, b, c, d \in \mathbf{R^2}$ は2次元ベクトルです。</p>

\[\begin{align*} 
P(t) &amp;= at^3+bt^2+ct+d \\
P'(t) &amp;= 3at^2+2bt+c
\end{align*}\]

<p>関数 $P(t)$ は2次元ベクトル、すなわちx-y座標を出力し、$P(0)$ が開始点、$P(1)$ が終了点になるように定義します。特に、$P(t)$ および $P’(t)$ に 0 および 1 を代入すると次のようになります。</p>

\[\begin{align*}
P(0) = P_0 &amp;= d\\
P(1) = P_1 &amp;= a + b + c + d\\
P'(0) = P_2 &amp;= c\\
P'(1) = P_3 &amp;= 3a + 2b + c
\end{align*}\]

<p>これを行列形式で書き直すと：</p>

\[\begin{bmatrix} P_0 \\ P_1 \\ P_2 \\ P_3 \end{bmatrix}
=
\begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
3 &amp; 2 &amp; 1 &amp; 0
\end{bmatrix}
\begin{bmatrix} a \\ b \\ c \\ d \end{bmatrix}\]

<p>この逆行列を使って：</p>

\[\begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
3 &amp; 2 &amp; 1 &amp; 0
\end{bmatrix}^{-1}
\begin{bmatrix} P_0 \\ P_1 \\ P_2 \\ P_3 \end{bmatrix}
=
\begin{bmatrix} a \\ b \\ c \\ d \end{bmatrix}\]

<p>ガウス消去法で逆行列を求めると：</p>

\[\begin{bmatrix} a \\ b \\ c \\ d \end{bmatrix}
=
\begin{bmatrix}
2 &amp; -2 &amp; 1 &amp; 1 \\
-3 &amp; 3 &amp; -2 &amp; -1 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0 &amp; 0
\end{bmatrix}
\begin{bmatrix} P_0 \\ P_1 \\ P_2 \\ P_3 \end{bmatrix}\]

<p>したがって、係数に基づいたパラメトリック方程式は次のようになります：</p>

\[\begin{align*}
P(t) &amp;=
\begin{bmatrix} t^3 &amp; t^2 &amp; t &amp; 1 \end{bmatrix}
\begin{bmatrix}
2 &amp; -2 &amp; 1 &amp; 1 \\
-3 &amp; 3 &amp; -2 &amp; -1 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0 &amp; 0
\end{bmatrix}
\begin{bmatrix} P_0 \\ P_1 \\ P_2 \\ P_3 \end{bmatrix} \\
&amp;= 
\begin{bmatrix} 
2t^3-3t^2+1 &amp; -2t^3+3t^2 &amp; t^3-2t^2+t &amp; t^3-t^2 
\end{bmatrix}
\begin{bmatrix} P_0 \\ P_1 \\ P_2 \\ P_3 \end{bmatrix} \\
\end{align*}\]

<p>ゆえに、</p>

\[P(t) = P_0 h_1 + P_1 h_2 + P_2 h_3 + P_3 h_4\]

<p>ここで、</p>

<p>$h_{1}(t) = 2t^3-3t^2+1$<br />
$h_{2}(t) = -2t^3 + 3t^2$<br />
$h_{3}(t) = t^3-2t^2+t$<br />
$h_{4}(t) = t^3-t^2$</p>

<p>$h_{1}(t)$ から $h_{4}(t)$ は「エルミート基底関数」と呼ばれます。</p>

<h3 id="速度プロファイル">速度プロファイル</h3>

<p>実際には、補間関数は各試合前のロボット初期化時間中に離散的にサンプリングされます。サンプリング時には、経路の1次・2次導関数の離散的な近似も計算可能です。この情報は、特に高速移動するロボットが急カーブで転倒しないように速度をスケーリングする際に有用です。</p>

<p>ここでの目標は、直感的なパラメータを柔軟な速度プロファイルに変換できる関数を定義することです。関数は以下の6つのパラメータで定義されます：</p>

<p>$d$ ::= プロファイルの全体距離<br />
$m$ ::= 最大速度<br />
$k_1$ ::= 加速定数<br />
$k_2$ ::= 減速定数<br />
$s_1$ ::= 初期速度<br />
$s_2$ ::= 最終速度</p>

<p>これらの6つのパラメータで、比較的自由度の高い速度プロファイルを定義することができます。</p>

<p>まず、シグモイド関数の一般形を定義します。ただし、$a_i, b_i$ は定数です。</p>

\[f(x) = \frac{1}{1 - a_ie^{-b_ix}} \left( a_i &gt; 0, b_i &gt; 0 \right)\]

<p>曲線の「急峻さ」は、指数係数 $b_i$ によって決まるため、</p>

\[b_i = k_1\]

<p>次に、$f(0) = s_1$ となるように、$a_i$ を以下のように導出します。</p>

\[s_1 = f(0) = \frac{1}{1 + a_i}
\implies a_i = \frac{1}{s_1} - 1\]

<p>同様に、プロファイルの減速側は、反転シグモイド関数で表され、$a_f, b_f$ を定数とします。</p>

\[g(x) = \frac{1}{1 - a_fe^{b_fx}} \left( a_f &gt; 0, b_f &gt; 0 \right)\]

<p>このグラフの $g(0)$ が $x=d$ に一致するよう、右に $d$ だけシフトします。</p>

\[g(x) = \frac{1}{1 - a_fe^{b_f(x-d)}} \left( a_f &gt; 0, b_f &gt; 0 \right)\]

<p>最後に、2つの関数を掛け合わせ、最大速度 $m$ を掛けることで、最終的なプロファイルが得られます。</p>

<p><img src="/assets/2025-5-28-Path-Planner/profile.svg" alt="Velocity Profile" title="プレゼン資料の一部" /></p>

\[mf(x)g(x) = 
\frac{m}{
  \{ 1 + ( \frac{m}{s_1} - 1 ) e^{-k_1x} \} 
  \{ 1 + ( \frac{m}{s_2} - 1 ) e^{k_2(x - d)} \} 
}\]

<h3 id="ホロノミック制御の詳細">ホロノミック制御の詳細</h3>

<p>ホロノミックドライブとは、理論上すべての方向に移動・同時に回転可能なロボットの駆動機構です。VEXロボティクスでは、シンプルさから「X-drive（クロスドライブ）」が主流です。ただし、高校レベルでは制御が難しいため、その性能は十分には活用されていません。</p>

<p>例として、左スティック入力 $(l_x, l_y)$、右スティック入力 $(r_x, r_y)$ を持つコントローラーを用いた場合：</p>

\[\mathbf{v} = 
\begin{bmatrix} l_x \\ l_y \end{bmatrix}
\ \ \ \ 
\omega = r_x\]

<p>ここで $\mathbf{v}$ は<strong>フィールド基準のロボット速度</strong>を、$\omega$ は角速度を表します。「フィールド基準」とは、ロボットの向きに関係なく、スティックを一定方向に倒すと常にフィールド上でその方向に進むことを意味します。</p>

<p>このような制御方式は、<strong>フィールドセンター方式（field-centric）</strong>と呼ばれます。ロボットの向きを測定するためにはジャイロスコープを使用し、ここではその角度を $\theta$ とします。入力ベクトル $\mathbf{v}$ を $-\theta$ 回転（反時計回り）することで、フィールド基準の入力をロボット基準に変換します：</p>

\[\mathbf{v_{robot}} =
\begin{bmatrix}
  \cos(-\theta) &amp; - \sin(-\theta) \\
  \sin(-\theta) &amp; \cos(-\theta)
\end{bmatrix}
\begin{bmatrix} l_x \\ r_x \end{bmatrix}\]

<p>たとえばロボットが90度右を向いているとき、左スティックを前に倒すと、フィールド上では右に動くことになります。これを打ち消すには、入力を90度反時計回りに回転させます。こうすることで、入力方向とフィールド上の進行方向が一致します。</p>

<p>この処理は、「<strong>ワールド座標系の入力をロボット座標系に変換する</strong>」ということでもあります。</p>

<p><img src="/assets/2025-5-28-Path-Planner/xdrive.svg" alt="X-drive" title="プレゼン資料の一部" /></p>

<p>次に、$\mathbf{v}$ を $\mathbf{v_{robot}}$ に置き換え、各ホイールの動作を決定します。X-driveは全方向駆動が可能なため、各ホイールの進行方向に対応する単位ベクトルとの内積をとって回転量を算出します。具体的には次のように定義します：</p>

\[\mathbf{v_{fl}} = \begin{bmatrix} \cos(45) \\ \sin(45) \end{bmatrix}
\mathbf{v_{fr}} = \begin{bmatrix} \cos(135) \\ \sin(135) \end{bmatrix}
\mathbf{v_{rl}} = \begin{bmatrix} \cos(135) \\ \sin(135) \end{bmatrix}
\mathbf{v_{rr}} = \begin{bmatrix} \cos(45) \\ \sin(45) \end{bmatrix}\]

<p>内積は、ベクトル同士の方向の一致度を測るもので、各ホイールの相対速度を決定するのに使えます。角速度 $\omega$ も考慮すると、各ホイールの速度は次のように定まります：</p>

\[\begin{align*}
v_{fl} &amp;= l_x * \cos(45)\ \ + l_y * \sin(45)\ \ + \omega \\  
v_{fr} &amp;= l_x * \cos(135) + l_y * \sin(135) - \omega \\    
v_{rl} &amp;= l_x * \cos(135) + l_y * \sin(135) + \omega \\    
v_{rr} &amp;= l_x * \cos(45)\ \  + l_y * \sin(45)\ \  - \omega
\end{align*}\]

<p>その後、これらの値を最大値で割って正規化することで、モーターの出力が1を超えないようにします。これは、内積に基づく相対的な関係を維持する上で非常に重要です。</p>

<p>この実装では、ジャイロスコープとともにオドメトリエンコーダーを用いて、ロボットの自己位置推定を行います。エンコーダーの速度を離散的に積分し、毎回の位置変化を算出します。これらの変位ベクトルはロボット座標系で表されているため、ジャイロスコープ角を用いて回転させることで、フィールド基準の位置を求めます。移動距離も、変位ベクトルの大きさを積分することで計算可能であり、これは経路追従に使用されます。</p>

<h3 id="desmos-ui">Desmos UI</h3>

<p><a href="https://www.desmos.com/calculator/zqpztqvvoi">Path Planner</a><br />
<a href="https://www.desmos.com/calculator/dg7kybaxyb">Path Planner Plus</a></p>

<p>上記の2つのDesmosグラフは、軌道生成のためのユーザーインターフェースとして機能します。ロボットの初期および最終座標や「速度」を表す点は、画面上でドラッグ可能です。エルミートスプラインの特性に従い、初期および最終の「速度」を長くすればするほど、その角度が経路に与える影響（制御力）が大きくなります。</p>

<p>Path Planner Plusのグラフは、拡張された軌道生成方式のUIとして機能し、2つのエルミートスプラインによる分割補間です。経路に中間点と「速度」を1つ追加することで、中央付近の経路の挙動をより詳細に制御できます。</p>

<h1 id="実装">実装</h1>

<p>以下のコードは、上記理論に基づいた直接的かつ素朴な実装例です。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">/// @brief エルミート補間式にある処理位置（x）を問い、そ地点の姿勢を返す</span>
  <span class="c1">/// @param path エルミート補間式の定義</span>
  <span class="c1">/// @param previous 前回の処理位置の姿勢</span>
  <span class="c1">/// @param x 処理位置（0から１）</span>
  <span class="c1">/// @return 処理位置（x）のロボット姿勢</span>
  <span class="n">Pose</span> <span class="nf">CubicHermiteInterpolation</span><span class="p">(</span><span class="n">Path</span> <span class="n">path</span><span class="p">,</span> <span class="n">Pose</span> <span class="n">previous</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// エルミート補間多項式の表現</span>
    <span class="kt">float</span> <span class="n">h1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">h2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">h3</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">h4</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
    <span class="c1">// エルミート補間定義に従い処理位置（x）の姿勢を導く</span>
    <span class="n">Pose</span> <span class="n">current</span><span class="p">;</span>
    <span class="n">current</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">h2</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">t0</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">h3</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">t1</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">h4</span><span class="p">;</span>
    <span class="n">current</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">h2</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">t0</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">h3</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">t1</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">h4</span><span class="p">;</span>
    <span class="c1">// 姿勢の角度（進行方向）を導出</span>
    <span class="n">current</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">Vector</span> <span class="p">{</span><span class="n">current</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">previous</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">current</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">previous</span><span class="p">.</span><span class="n">y</span><span class="p">}.</span><span class="n">getAngle</span><span class="p">();</span> 
    <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>$t$ の値だけがループ内で変化するため、入力行列とパラメータをあらかじめまとめておくことで、各係数の再計算を回避できます：</p>

\[P(t) =
\begin{bmatrix} t^3 &amp; t^2 &amp; t &amp; 1 \end{bmatrix}
\begin{bmatrix}
2P_0 &amp; -2P_1 &amp; 1P_2 &amp; 1P_3 \\
-3P_0 &amp; 3P_1 &amp; -2P_2 &amp; -1P_3 \\
0 &amp; 0 &amp; 1P_1 &amp; 0 \\
1P_0 &amp; 0 &amp; 0 &amp; 0
\end{bmatrix}\]

<p>ホロノミックドライブでは、「速度」方向とは別に姿勢角を独立して定義することができます。経路の開始を0、終了を1として、途中で向くべき角度のリスト（HolonomicPose）を渡すことで、ロボットの姿勢制御が可能になります。たとえば {0.5, 180} は、経路の中間点（0.5の位置）で180度を向くべきことを意味します。</p>

<p>これらの距離と角度のペアを線形補間し、経路離散化時に滑らかに角度が変化するようにします。以下がそのコードです：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">/// @param dist 特定する処理位置 (0 から 1)</span>
  <span class="c1">/// @param angle　ロボットの角度</span>
  <span class="k">struct</span> <span class="nc">HolonomicPose</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">dist</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">angle</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">/// @brief ホロノミック姿勢の std::vector をある処理位置　x で補間。</span>
  <span class="c1">/// 目的姿勢を提示された経路位置に厳密に達成する為に滑らか且つ徐々に近づいていく必要がある。</span>
  <span class="c1">/// この関数は提示された処理位置を用いて全ての処理位置のあるべき姿勢を導く役割を果たす。</span>
  <span class="c1">/// @param orientation ホロノミック姿勢の　std::vector （処理位置０と１の姿勢は必ず定義されている）</span>
  <span class="c1">/// @param x 処理位置</span>
  <span class="c1">/// @return 補間値</span>
  <span class="kt">float</span> <span class="n">InterpolateHolonomicPose</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">HolonomicPose</span><span class="o">&gt;</span> <span class="n">orientation</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">orientation</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">//　ホロノミック姿勢が示されているか</span>
      <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//　イテレータ初期化</span>
      <span class="c1">//　std::vector から現在の処理位置（x）が入る区間を探る</span>
      <span class="c1">//　区間の先頭と後尾の角度と処理位置の差を取ることで直線補間を行うことができる</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">s</span><span class="o">++</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">orientation</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//　std::vector を探索</span>
      <span class="kt">float</span> <span class="n">angleError</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">angle</span><span class="p">,</span> <span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">angle</span><span class="p">);</span>        <span class="c1">//　区間の最短角度差を求める</span>
      <span class="kt">float</span> <span class="n">distError</span> <span class="o">=</span> <span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">dist</span> <span class="o">-</span> <span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">dist</span><span class="p">;</span>                <span class="c1">//　区間の処理位置の差を求める</span>
      <span class="n">x</span> <span class="o">-=</span> <span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">dist</span><span class="p">;</span>                                                      <span class="c1">//  </span>
      <span class="k">return</span> <span class="n">bound</span><span class="p">(</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">distError</span><span class="p">)</span> <span class="o">*</span> <span class="n">angleError</span> <span class="o">+</span> <span class="n">orientation</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">angle</span> <span class="p">);</span>           <span class="c1">//  直線補間を行う</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//　ホロノミック姿勢が示されてない場合（ー１）を返す</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>次に、経路を離散化する処理を行います。「明瞭度（clarity）」は、デフォルトで100点に設定されており、経路、速度プロファイル、および姿勢角度をそれぞれサンプリングしてWaypointとして格納します。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">struct</span> <span class="nc">Waypoint</span> <span class="p">{</span>
      <span class="n">PathType</span> <span class="n">type</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">dist</span><span class="p">;</span>
      <span class="n">Pose</span> <span class="n">heading</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="c1">/// @brief 軌道を生成する関数</span>
    <span class="c1">/// @param path エルミート補間式の定義</span>
    <span class="c1">/// @param orientation ホロノミック姿勢の　std::vector </span>
    <span class="c1">/// @param clarity 明瞭度を示す（一つの経路は100と定められている）</span>
    <span class="c1">/// @param profile 速度プロフィール</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Waypoint</span><span class="o">&gt;</span> <span class="n">generate</span><span class="p">(</span><span class="n">Path</span> <span class="n">path</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">HolonomicPose</span><span class="o">&gt;</span> <span class="n">orientation</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clarity</span><span class="p">,</span> <span class="n">StaticProfile</span> <span class="n">profile</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">segment</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">clarity</span><span class="p">;</span> <span class="c1">//　処理位置の一つ一つの区間の長さを導く</span>
        <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//　経路の長さを初期化</span>
        <span class="c1">// 現在姿勢と前回姿勢を宣言</span>
        <span class="n">Pose</span> <span class="n">previous</span> <span class="p">{</span><span class="n">path</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">t0</span><span class="p">.</span><span class="n">getAngle</span><span class="p">()};</span> <span class="c1">//　点Aの姿勢に設定　</span>
        <span class="n">Pose</span> <span class="n">current</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span> <span class="c1">//　初期化</span>
        <span class="c1">//　軌道となる経由地の配列を作成</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Waypoint</span><span class="o">&gt;</span> <span class="n">waypoints</span><span class="p">;</span>
        <span class="c1">//　明瞭度の分繰り返される（イテレータは1から始める）</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">clarity</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 現在処理位置を求める</span>
            <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">segment</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
            <span class="c1">// 処理位置を元に現在の姿勢を求める</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">CubicHermiteInterpolation</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
            <span class="c1">// 現在と前回の姿勢の差を（previous）に導入</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span><span class="p">.</span><span class="n">getError</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
            <span class="c1">// 現在角度と前回角度の差を比例拡大して逆数を取ります（この値は経路の曲率が高いほど小さくなる）</span>
            <span class="c1">// 速度プロフィールの現在処理値値を計算（区分的補間の場合、二番目の補間の際　index　が50となっている）</span>
            <span class="c1">// 上記の値はどちらとも0から1の範囲で、掛け合わせることで現在処理位置での速度を導ける。</span>
            <span class="kt">float</span> <span class="n">speed</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">autonomous_rotation_scaler</span> <span class="o">*</span> <span class="n">fabs</span><span class="p">(</span><span class="n">previous</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">profile</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">index</span><span class="p">));</span>
            <span class="c1">// 経由地に代入していく</span>
            <span class="n">Waypoint</span> <span class="n">waypoint</span><span class="p">;</span>
            <span class="n">waypoint</span><span class="p">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">length</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">+</span> <span class="n">previous</span><span class="p">.</span><span class="n">getVector</span><span class="p">().</span><span class="n">getMagnitude</span><span class="p">();</span> <span class="c1">//　各経由地間の距離の合計</span>
            <span class="c1">// ロボットを最終的に動かす関数がコントローラの入力を予想している為、アナログスティックの出力の近似</span>
            <span class="c1">// アナログスティックの出力の模倣は、進行方向と同じ角度の単位ベクトルで、その方向に全速力で進むことを意味する</span>
            <span class="c1">// 速度にかけることで適切な速度規制を可能とする</span>
            <span class="n">waypoint</span><span class="p">.</span><span class="n">heading</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cosf</span><span class="p">(</span><span class="n">previous</span><span class="p">.</span><span class="n">getVector</span><span class="p">().</span><span class="n">getAngle</span><span class="p">()</span> <span class="o">/</span> <span class="n">RadToDeg</span><span class="p">)</span> <span class="o">*</span> <span class="n">speed</span><span class="p">;</span> 
            <span class="n">waypoint</span><span class="p">.</span><span class="n">heading</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">sinf</span><span class="p">(</span><span class="n">previous</span><span class="p">.</span><span class="n">getVector</span><span class="p">().</span><span class="n">getAngle</span><span class="p">()</span> <span class="o">/</span> <span class="n">RadToDeg</span><span class="p">)</span> <span class="o">*</span> <span class="n">speed</span><span class="p">;</span>
            <span class="c1">// この処理位置で以前定義した「ホロノミック姿勢補間関数」を呼び出しあるべき角度を保存                </span>
            <span class="n">waypoint</span><span class="p">.</span><span class="n">heading</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">InterpolateHolonomicPose</span><span class="p">(</span><span class="n">orientation</span><span class="p">,</span> <span class="n">aIndex</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
            <span class="n">waypoints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">waypoint</span><span class="p">);</span><span class="c1">// 経由地を軌道に加える</span>
            <span class="c1">// 次のループに備える</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">+</span> <span class="n">previous</span><span class="p">.</span><span class="n">getVector</span><span class="p">().</span><span class="n">getMagnitude</span><span class="p">();</span> <span class="c1">// 今回の経由地間を合計距離にたす</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span> <span class="c1">// 今回の姿勢を前回の姿勢に代入</span>
        <span class="p">}</span>
        <span class="c1">// 初期姿勢と最終姿勢を定義。ホロノミック姿勢が示されていたら従って代入</span>
        <span class="k">this</span> <span class="o">-&gt;</span> <span class="n">initialPose</span> <span class="o">=</span> <span class="n">Pose</span> <span class="p">{</span><span class="n">path</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">orientation</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">orientation</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">angle</span><span class="p">};</span>
        <span class="k">this</span> <span class="o">-&gt;</span>   <span class="n">finalPose</span> <span class="o">=</span> <span class="n">Pose</span> <span class="p">{</span><span class="n">path</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">orientation</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">orientation</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">angle</span> <span class="p">};</span>
        <span class="k">this</span> <span class="o">-&gt;</span>      <span class="n">length</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>    <span class="c1">// 経路の最終的長さは経由地間の距離の合計である</span>
        <span class="k">this</span> <span class="o">-&gt;</span>      <span class="n">aIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1">// 区分的補間を行う場合ホロノミック姿勢をつける為</span>
        <span class="k">this</span> <span class="o">-&gt;</span>       <span class="n">index</span> <span class="o">=</span> <span class="n">clarity</span><span class="p">;</span> <span class="c1">// 区分的補間を行う場合速度プロフィールを継げる為</span>
        <span class="k">return</span> <span class="n">waypoints</span><span class="p">;</span>              <span class="c1">// 軌道を呼び出し主に返す</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>ホロノミック車台のフィールドセンター方式コードも次に示します。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">arcadeDrive</span><span class="p">(</span> <span class="n">Vector</span> <span class="n">translation</span><span class="p">,</span> <span class="kt">float</span> <span class="n">w</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 運転士視点操作の場合得られた横断ベクトルをロボットの角度の分、逆回転</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fieldCentric</span><span class="p">)</span> <span class="n">translation</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span> <span class="o">-</span><span class="n">pose</span><span class="p">.</span><span class="n">w</span> <span class="p">);</span>
      <span class="kt">float</span> <span class="n">fr</span> <span class="o">=</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">FR_component</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">FR_component</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">w</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">fl</span> <span class="o">=</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">FL_component</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">FL_component</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">rl</span> <span class="o">=</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">RL_component</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">RL_component</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">rr</span> <span class="o">=</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">RR_component</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="n">translation</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">RR_component</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">w</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="n">fmax</span><span class="p">(</span> <span class="n">fmax</span><span class="p">(</span> <span class="n">fabs</span><span class="p">(</span><span class="n">fr</span><span class="p">),</span> <span class="n">fabs</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span> <span class="p">),</span> <span class="n">fmax</span><span class="p">(</span> <span class="n">fabs</span><span class="p">(</span><span class="n">rl</span><span class="p">),</span> <span class="n">fabs</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 正規化</span>
          <span class="n">fr</span> <span class="o">/=</span> <span class="n">max</span><span class="p">;</span>
          <span class="n">fl</span> <span class="o">/=</span> <span class="n">max</span><span class="p">;</span>
          <span class="n">rl</span> <span class="o">/=</span> <span class="n">max</span><span class="p">;</span>
          <span class="n">rr</span> <span class="o">/=</span> <span class="n">max</span><span class="p">;</span> 
      <span class="p">}</span>
      <span class="n">fr</span> <span class="o">*=</span> <span class="n">WHEEL_MAX_RPM</span><span class="p">;</span>  <span class="c1">// 適当な速度を導く</span>
      <span class="n">fl</span> <span class="o">*=</span> <span class="n">WHEEL_MAX_RPM</span><span class="p">;</span>  <span class="c1">// 適当な速度を導く</span>
      <span class="n">rl</span> <span class="o">*=</span> <span class="n">WHEEL_MAX_RPM</span><span class="p">;</span>  <span class="c1">// 適当な速度を導く</span>
      <span class="n">rr</span> <span class="o">*=</span> <span class="n">WHEEL_MAX_RPM</span><span class="p">;</span>  <span class="c1">// 適当な速度を導く</span>
      <span class="n">FR</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">fr</span><span class="p">,</span> <span class="n">vex</span><span class="o">::</span><span class="n">velocityUnits</span><span class="o">::</span><span class="n">rpm</span><span class="p">);</span>  <span class="c1">// モータに速度命令</span>
      <span class="n">FL</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">vex</span><span class="o">::</span><span class="n">velocityUnits</span><span class="o">::</span><span class="n">rpm</span><span class="p">);</span>  <span class="c1">// モータに速度命令</span>
      <span class="n">RL</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">rl</span><span class="p">,</span> <span class="n">vex</span><span class="o">::</span><span class="n">velocityUnits</span><span class="o">::</span><span class="n">rpm</span><span class="p">);</span>  <span class="c1">// モータに速度命令</span>
      <span class="n">RR</span><span class="p">.</span><span class="n">spin</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">rr</span><span class="p">,</span> <span class="n">vex</span><span class="o">::</span><span class="n">velocityUnits</span><span class="o">::</span><span class="n">rpm</span><span class="p">);</span>  <span class="c1">// モータに速度命令</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最後に、経路を実行するプログラムを次に示す。自己位置推定によって「distanceTraveled」という変数を更新し、軌道の進捗状況を把握し、次の「Waypoint」を受け取る。この「Waypoint」を用いて適切なコントローラ入力を数値的に再現する。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">/// @brief 経路を実行</span>
    <span class="c1">/// @param trajectory 走る経路</span>
    <span class="c1">/// @return 実行の捗り (0から1)</span>
    <span class="kt">float</span> <span class="nf">follow</span><span class="p">(</span><span class="n">HolonomicTrajectory</span> <span class="n">trajectory</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">localize</span><span class="p">();</span> <span class="c1">// 自己位置推定手法を更新</span>
        <span class="kt">float</span> <span class="n">progress</span> <span class="o">=</span> <span class="n">fitToRange</span><span class="p">(</span> <span class="n">distanceTraveled</span> <span class="o">/</span> <span class="n">trajectory</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span> <span class="c1">// 実行捗りを求める</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">progress</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// 実行が終了わってない限り</span>
            <span class="n">Waypoint</span> <span class="n">waypoint</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">distanceTraveled</span><span class="p">);</span> <span class="c1">// 走った距離を用い経路から次の経由地を特定</span>
            <span class="c1">//　ホロノミック姿勢の場合、PID制御を用いて目的角度を到達するために適切な出力を導く。</span>
            <span class="c1">//　概念的には、現在角度と目的角度の最短差を導き、その差が０に近づけるよに出力量を決める</span>
            <span class="kt">float</span> <span class="n">w</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">.</span><span class="n">orientation</span> <span class="o">?</span> <span class="n">omegaPID</span><span class="p">.</span><span class="n">get</span><span class="p">(</span> <span class="n">wrap</span><span class="p">(</span><span class="n">pose</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">waypoint</span><span class="p">.</span><span class="n">heading</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">arcadeDrive</span><span class="p">(</span> <span class="n">Vector</span> <span class="p">{</span><span class="n">waypoint</span><span class="p">.</span><span class="n">heading</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">waypoint</span><span class="p">.</span><span class="n">heading</span><span class="p">.</span><span class="n">y</span><span class="p">},</span> <span class="n">w</span> <span class="p">);</span> <span class="c1">// コントローラ操作の関数に入力</span>
            <span class="k">return</span> <span class="n">progress</span><span class="p">;</span> <span class="c1">//　実行捗りを毎回返す</span>
        <span class="p">}</span>      
        <span class="n">stop</span><span class="p">();</span>   <span class="c1">// モータを全て停止</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 経路が無事実行されたことを再び示す</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>武藤皐蘭</name></author><category term="projects" /><summary type="html"><![CDATA[このプロジェクトでは、差動駆動およびホロノミック Vex ロボットの滑らかな経路生成における Cubic Hermite Spline の応用について詳述します。経路生成は Desmos の使用により簡略化されています。また、本プロジェクトでは、初速度と最終速度、初期加速度と最終加速度、移動距離を与えたときの速度プロファイルを生成する簡単な方法も提案しています。これは高校最終学年の間に取り組んだプロジェクトであり、多くの改善の余地が残されていますが、その一部を本記事で紹介します。]]></summary></entry></feed>