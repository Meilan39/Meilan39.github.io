var store = [{
        "title": "文化遺産の保存と共有のための３次元復元（英語版）- 共同研究",
        "excerpt":"Some would say that we are currently living through the information age, a universal turning point for civilization which has the potential to rival the agricultural and industrial revolution in terms of societal impact. One important aspect of the information age is that it has enabled the sharing of information...","categories": ["projects"],
        "tags": [],
        "url": "/projects/3D-Reconstruction/",
        "teaser": null
      },{
        "title": "C89コンパイラのパーサをCで実装",
        "excerpt":"プログラムに携わるエンジニアとしてコンパイラは当然のように使う道具である。ただし、その裏には人間の意思を機械が実行できる指示に変換するための奥深い技術がある。また、コンパイラを勉強することによって、コンパイルエラーの処理能力が強化されたり、その言語の理解度が深まるといった利点が挙げられる。当然のように使う道具への感謝意識を持つことも技術者として大切なように思える。 本記事では、近代の情報技術の著しい発展の基盤となるコンパイラを解明し、C89コンパイラの解析部分の一部をC言語で実装した過程を示す。流れとしては、2章でコンパイラの概要を説明し、3章で重要な補足としてBNF（Backus-Naur form）を説明したのち、4章から6章にかけてコンパイラの解析部分を実際のコードとともに解説し、7章で実際に入力テストを通してパーサーを検証する。 2. コンパイラの概要 コンパイラはその言語の規則に従って書かれた文字列を機械語に変換する、いわば翻訳プログラムである。図1で示すコンパイラの構造は、おおよそ「解析部分」と「変換部分」に分けて考えることができる。コンパイラの解析部分では、入力コードの文字列を解析して意味を抽出する。解析部分に含めている最適化では、抽出された意味をもって最適な形に変換する。最後に変換部分では、抽出かつ最適化された意味から機械語を生成し、リンキング段階でライブラリや関連ファイルを結合させ、実行可能な機械語を出力する。本レポートでは解析部分の字句解析と構文解析の実装について解説する[1]。 図1：コンパイラの構造   プログラミング言語はあらゆる言語と同様に、字句と文法によって規定される。字句は言語を構成する最小の単位をなし、文法は字句の規則正しい繋がりを共有するルールである。図1の「字句解析」は入力されたコードから、意味をなす最小の単位である、人間言語でいう単語を抽出する役割がある。この際に、余計なスペースや解析不要なコメントなどを読み飛ばす。「構文解析」では抽出した字句の繋がりを文法規定に当てはめ、初めて指示として意味をなす、人間言語でいう「文」として解釈する役割がある。この際に、コードの意味を最簡な形で表す「抽象構文木」を同時に作成する。「意味解析」では、構文解析で生成した抽象構文木を用いて,型検査などの構文を超越して、人間言語における文章レベルで意味の確認を行う[1]。 ここで重要な注意点として、コンパイラを実装する一つ目の難しさは、ユーザーが誤った入力をする可能性である。字句解析の段階では許容される字句から構成されていること、構文解析の段階では許容される文法に当てはまること、を全ての字句と文法ルールについて確認する必要がある。これについては4章と5章で詳しく解説する。 3. BNF（Backus–Naur form） コンパイラを実装する二つ目の難しさは文法の複雑さである。そこで、コンピュータ言語の文法記述はBNF（Backus-Naur form）という表記法を用いて表すことにする。BNFには様々な種類や標準があるが、本レポートで扱うBNFは表1の記号からなるものとする。 表1：本レポートで用いるBNF表記法 記号 説明 範囲 ::= 左辺を右辺で定義する   &lt;&gt; 中に名前を入れて変数を表す   {} 普通の括弧のように使う   | どちらかを選択する（OR）   * 前の要素は何回でも繰り返していい “{0, }” + 前の要素は1回以上の繰り返しを許す “{1, }” ? 前の要素は0か1回の繰り返しを許す “{0, 1}” 例えば、本レポートで使うC89のBNF [2] はプログラム1のように始まる。プログラム1を読み解くと、「translation-unit」は「external-declaration」を何回でも繰り返したもので定義される。また、「external-declaration」は「function-definition」もしくは「declaration」と定義されている。 プログラム1：C89のBNFの非終端要素の例 [2] &lt;translation-unit&gt; ::=...","categories": ["projects"],
        "tags": [],
        "url": "/projects/C89-Parser/",
        "teaser": null
      },{
        "title": "差動駆動およびホロノミックロボット向け経路計画インターフェース",
        "excerpt":"このプロジェクトでは、差動駆動およびホロノミック Vex ロボットの滑らかな経路生成における Cubic Hermite Spline の応用について詳述します。経路生成は Desmos の使用により簡略化されています。また、本プロジェクトでは、初速度と最終速度、初期加速度と最終加速度、移動距離を与えたときの速度プロファイルを生成する簡単な方法も提案しています。これは高校最終学年の間に取り組んだプロジェクトであり、多くの改善の余地が残されていますが、その一部を本記事で紹介します。 リンク GitHubリポジトリ プレゼンテーション 開始点・終了点および速度を可視化できる通常のPath Plannerバージョン。 Path Planner 開始点・中間点・終了点および速度を可視化できるPath Planner Plusバージョン。Path Planner Plusは、長いまたは複雑な経路で追加の中間点が必要な場合に最適です。 Path Planner Plus 使用ツール C++ Desmos 動機 VEX Robotics Competitionでは、「自律制御期間」と呼ばれる時間帯があり、ロボットは事前にプログラムされたルーチンを実行して得点します。多くのチームは、エンコーダ距離や時間ベースのアプローチを用いて、個別の直線経路を連続で実行しています。しかし、この方法では、目的地と現在地の間に障害物がある場合、複数の経路を順に実行する必要があり、非効率で大きな誤差が生じる可能性があります。このプロジェクトの動機は、2点間の連続的かつ柔軟な経路を簡単に生成できるインターフェースを作成することでした。 背景 三次エルミート補間 基本的なアイデアは、開始点と終了点、およびそれぞれに対応する「速度」ペアを使用して柔軟な経路を生成することです。開始点と終了点は経路の端点を定義し、「速度」はそれらの向きが経路の曲率に与える影響を示します。「速度」はロボットの実際の速度を意味するのではなく、端点の向きが経路形状に与える「重み」として扱われます。この問題は補間問題であり、ここではエルミートスプライン補間を用いています。エルミートスプラインは、数学的にはよく知られるベジエ曲線と同等とみなすことができますが、開始点と終了点の向きを明示的に定義できる点で、ロボット経路計画においてより適しています。一方、ベジエ曲線では、中間点が物理的意味を持たずに曲率を定義します。 上述のように、エルミートスプラインは以下の4つの情報から生成されます： $P_0$ ::= 開始点の x-y 座標 $P_1$ ::= 終了点の x-y 座標 $P_2$ ::= 開始点の「速度」 $P_3$ ::=...","categories": ["projects"],
        "tags": [],
        "url": "/projects/Path-Planner/",
        "teaser": null
      }]
